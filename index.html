<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥µé™å€–å­˜è€…ï¼šç„¡é™ç«åŠ› - é›²ç«¯å­˜æª”ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f172a; color: #f8fafc; font-family: 'Inter', sans-serif; overflow: hidden; }
        canvas { background-color: #111827; display: block; border-radius: 0.5rem; cursor: crosshair; }
        .hud { position: absolute; pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        #xpBarContainer {
            position: absolute; top: 0; left: 0; width: 100%; height: 8px;
            background: #1e293b; z-index: 10;
        }
        #xpBar { width: 0%; height: 100%; background: #3b82f6; transition: width 0.2s; }
        .damage-flash { animation: flash 0.15s; }
        @keyframes flash { 0% { background: rgba(220, 38, 38, 0.5); } 100% { background: transparent; } }
        .save-indicator { position: fixed; bottom: 1rem; right: 1rem; font-size: 0.75rem; color: #4ade80; opacity: 0; transition: opacity 0.5s; }
    </style>
</head>
<body class="flex items-center justify-center h-screen m-0">

    <div id="xpBarContainer"><div id="xpBar"></div></div>
    <div id="saveIndicator" class="save-indicator">å·²åŒæ­¥é›²ç«¯é€²åº¦...</div>

    <div class="relative w-full h-full">
        <canvas id="gameCanvas"></canvas>
        <div class="hud top-4 left-4 text-green-400 font-bold" id="hpUI">HP: 100 / 100</div>
        <div class="hud top-4 right-4 text-yellow-400 font-bold" id="scoreUI">SCORE: 0</div>
        <div class="hud top-12 left-1/2 -translate-x-1/2 text-slate-500 text-xs" id="levelUI">LEVEL 1</div>
        <div class="hud bottom-4 left-1/2 -translate-x-1/2 text-blue-400 font-bold animate-pulse">é›²ç«¯å­˜æª”åŠŸèƒ½å·²å•Ÿå‹•</div>
    </div>

    <!-- åˆå§‹ä»‹é¢ -->
    <div id="startMenu" class="absolute inset-0 bg-slate-900/95 flex flex-col items-center justify-center z-50">
        <h1 class="text-6xl font-black mb-2 text-blue-500 text-center">æ¥µé™ç”Ÿå­˜<br><span class="text-3xl text-yellow-500">é›²ç«¯å­˜æª”ç‰ˆ</span></h1>
        <div id="userStats" class="mb-8 text-center bg-slate-800 p-4 rounded-xl border border-slate-700">
            <p class="text-slate-400">æœ€é«˜å¾—åˆ†: <span id="highScoreText" class="text-yellow-400 font-bold">è¼‰å…¥ä¸­...</span></p>
            <p class="text-slate-400">ç•¶å‰ UID: <span id="userIdDisplay" class="text-xs text-blue-300">å–å¾—ä¸­...</span></p>
        </div>
        <button id="btnStart" class="bg-blue-600 hover:bg-blue-500 px-12 py-4 rounded-full text-2xl font-bold transition-all transform hover:scale-110 shadow-lg shadow-blue-500/50">é€²å…¥æˆ°å ´</button>
    </div>

    <!-- å‡ç´šä»‹é¢ -->
    <div id="upgradeMenu" class="hidden absolute inset-0 bg-slate-950/90 flex flex-col items-center justify-center z-40">
        <h2 class="text-4xl font-black mb-8 text-blue-400">ç«åŠ›é€²éšï¼é¸æ“‡æ›´å¼·çš„å¼·åŒ–</h2>
        <div id="upgradeOptions" class="flex gap-6"></div>
    </div>

    <!-- çµæŸä»‹é¢ -->
    <div id="deathMenu" class="hidden absolute inset-0 bg-red-950/90 flex flex-col items-center justify-center z-50">
        <h1 class="text-6xl font-black mb-4 text-white">ä»»å‹™çµæŸ</h1>
        <p id="finalScore" class="text-2xl mb-2 text-red-200">å¾—åˆ†: 0</p>
        <p id="newRecordText" class="text-yellow-400 font-bold mb-8 opacity-0">æ–°ç´€éŒ„ï¼å·²å­˜æª”è‡³é›²ç«¯</p>
        <button onclick="location.reload()" class="bg-white text-red-900 px-10 py-3 rounded-full font-bold shadow-xl">å†æ¬¡æŒ‘æˆ°</button>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase é…ç½®èˆ‡åˆå§‹åŒ– (ä½¿ç”¨ç’°å¢ƒè®Šæ•¸)
        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'survivor-game-default';

        let currentUser = null;
        let userSaveData = { highScore: 0, totalUpgrades: 0 };

        // èªè­‰é‚è¼¯
        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("èªè­‰å¤±æ•—:", error);
            }
        };

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                document.getElementById('userIdDisplay').textContent = user.uid;
                await loadGameProgress();
            }
        });

        initAuth();

        // å­˜æª”èˆ‡è¼‰å…¥åŠŸèƒ½
        async function loadGameProgress() {
            if (!currentUser) return;
            const docRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saveData', 'progress');
            try {
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    userSaveData = docSnap.data();
                } else {
                    // åˆå§‹å­˜æª”
                    await setDoc(docRef, userSaveData);
                }
                document.getElementById('highScoreText').textContent = userSaveData.highScore;
            } catch (e) {
                console.error("è¼‰å…¥å­˜æª”å¤±æ•—:", e);
                document.getElementById('highScoreText').textContent = "0 (æœ¬åœ°æ¨¡å¼)";
            }
        }

        async function saveGameProgress(newScore) {
            if (!currentUser) return;
            const docRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saveData', 'progress');
            
            let needsUpdate = false;
            if (newScore > userSaveData.highScore) {
                userSaveData.highScore = newScore;
                needsUpdate = true;
                document.getElementById('newRecordText').style.opacity = 1;
            }

            try {
                await setDoc(docRef, userSaveData, { merge: true });
                showSaveIndicator();
            } catch (e) {
                console.error("å­˜æª”å¤±æ•—:", e);
            }
        }

        function showSaveIndicator() {
            const el = document.getElementById('saveIndicator');
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 2000);
        }

        // --- éŠæˆ²é‚è¼¯ ---
        const audio = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(f, t, d, v=0.03) {
            try {
                if (audio.state === 'suspended') audio.resume();
                const o = audio.createOscillator();
                const g = audio.createGain();
                o.type = t; o.frequency.setValueAtTime(f, audio.currentTime);
                g.gain.setValueAtTime(v, audio.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, audio.currentTime + d);
                o.connect(g); g.connect(audio.destination);
                o.start(); o.stop(audio.currentTime + d);
            } catch(e) {}
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let w, h, player;
        let gameActive = false;
        let enemies = [], bullets = [], orbs = [], items = [];
        let frame = 0, score = 0;
        let shootTimer = 0;

        const camera = {
            x: 0, y: 0,
            update: function(targetX, targetY) {
                this.x = targetX - w / 2;
                this.y = targetY - h / 2;
            }
        };

        const UPGRADES = {
            bullets: { name: "æ¥µé™å½ˆé“", desc: "å†å¢åŠ  2 æ¢å°„æ“Šè·¯ç·š", icon: "ğŸš€", level: 5, max: 20 },
            fireRate: { name: "è¶…é »é€£ç™¼", desc: "æ”»é€Ÿçªç ´å¤©éš›", icon: "ğŸ”¥", level: 5, max: 20 },
            damage: { name: "æ¯€æ»…å½ˆé ­", desc: "å‚·å®³ç¿»å€", icon: "ğŸ’£", level: 5, max: 20 },
            speed: { name: "é–ƒé›»ç§»å‹•", desc: "ç¬é–“ç§»å‹•æ„Ÿåè¶³", icon: "ğŸƒ", level: 0, max: 10 },
            magnet: { name: "å…¨åœ–æ‹¾å–", desc: "å¸å–ç¶“é©—ç¯„åœè¶…å¤§å¹…å¢åŠ ", icon: "ğŸª", level: 0, max: 10 }
        };

        function initCanvas() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', initCanvas);
        initCanvas();

        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        class Player {
            constructor() {
                this.x = 0; this.y = 0;
                this.r = 15; this.hp = 100; this.maxHp = 100;
                this.xp = 0; this.lv = 1; this.nextXp = 50;
                this.speed = 5; 
                this.pickupR = 120;
                this.damage = 25;
                this.fireRate = 5;
                this.bulletCount = 5;
                
                // ç¹¼æ‰¿å­˜æª”åŠ æˆï¼šæœ€é«˜åˆ†çš„ 1% æœƒè½‰åŒ–ç‚ºåˆå§‹å‚·å®³
                this.damage += Math.floor(userSaveData.highScore * 0.01);
            }
            update() {
                if (keys['KeyW'] || keys['ArrowUp']) this.y -= this.speed;
                if (keys['KeyS'] || keys['ArrowDown']) this.y += this.speed;
                if (keys['KeyA'] || keys['ArrowLeft']) this.x -= this.speed;
                if (keys['KeyD'] || keys['ArrowRight']) this.x += this.speed;
                
                shootTimer++;
                if (shootTimer >= this.fireRate) {
                    this.shoot();
                    shootTimer = 0;
                }
            }
            shoot() {
                let target = null;
                let minDist = 1000;
                enemies.forEach(e => {
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < minDist) { minDist = d; target = e; }
                });

                const angle = target ? Math.atan2(target.y - this.y, target.x - this.x) : -Math.PI/2;
                const spread = 0.35; 
                for (let i = 0; i < this.bulletCount; i++) {
                    const offset = (i - (this.bulletCount - 1) / 2) * spread;
                    bullets.push(new Bullet(this.x, this.y, angle + offset, this.damage));
                }
                playSfx(500, 'square', 0.05, 0.005);
            }
            draw() {
                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#3b82f6';
                ctx.beginPath();
                ctx.arc(0, 0, this.r, 0, Math.PI*2);
                ctx.fillStyle = '#3b82f6';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, angle, dmg) {
                this.x = x; this.y = y; this.dmg = dmg;
                this.vx = Math.cos(angle) * 15;
                this.vy = Math.sin(angle) * 15;
                this.r = 3;
                this.life = 120;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x - camera.x, this.y - camera.y, this.r, 0, Math.PI*2);
                ctx.fillStyle = '#60a5fa';
                ctx.fill();
            }
        }

        class Enemy {
            constructor() {
                const dist = 600;
                const angle = Math.random() * Math.PI * 2;
                this.x = player.x + Math.cos(angle) * dist;
                this.y = player.y + Math.sin(angle) * dist;
                this.r = 12 + Math.random() * 8;
                this.hp = 20 + player.lv * 12;
                this.speed = 1.0 + Math.random() * 1.5;
            }
            update() {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x - camera.x, this.y - camera.y, this.r, 0, Math.PI*2);
                ctx.fillStyle = '#ef4444';
                ctx.fill();
            }
        }

        class Orb {
            constructor(x, y) { this.x = x; this.y = y; this.r = 4; this.val = 10; }
            update() {
                const d = Math.hypot(player.x - this.x, player.y - this.y);
                if (d < player.pickupR) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x += Math.cos(angle) * 12;
                    this.y += Math.sin(angle) * 12;
                }
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x - camera.x, this.y - camera.y, this.r, 0, Math.PI*2);
                ctx.fillStyle = '#fbbf24';
                ctx.fill();
            }
        }

        function drawGrid() {
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 1;
            const gridSize = 100;
            const offsetX = -camera.x % gridSize;
            const offsetY = -camera.y % gridSize;
            ctx.beginPath();
            for (let x = offsetX; x < w; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
            for (let y = offsetY; y < h; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
            ctx.stroke();
        }

        function showUpgrade() {
            gameActive = false;
            document.getElementById('upgradeMenu').classList.remove('hidden');
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';
            const pool = Object.keys(UPGRADES).filter(k => UPGRADES[k].level < UPGRADES[k].max);
            const picks = pool.sort(() => 0.5 - Math.random()).slice(0, 3);
            picks.forEach(key => {
                const up = UPGRADES[key];
                const card = document.createElement('div');
                card.className = "bg-slate-800 p-6 rounded-xl border-2 border-slate-700 hover:border-blue-500 cursor-pointer w-48 text-center transition-all hover:scale-105 shadow-lg";
                card.innerHTML = `<div class="text-4xl mb-4">${up.icon}</div><div class="font-bold text-xl mb-2">${up.name}</div><div class="text-xs text-slate-400 leading-tight">${up.desc}</div><div class="mt-4 text-blue-400 font-mono">LV ${up.level}</div>`;
                card.onclick = () => { applyUpgrade(key); document.getElementById('upgradeMenu').classList.add('hidden'); gameActive = true; loop(); };
                options.appendChild(card);
            });
        }

        function applyUpgrade(key) {
            UPGRADES[key].level++;
            playSfx(600, 'triangle', 0.2, 0.1);
            if (key === 'bullets') player.bulletCount += 2;
            if (key === 'fireRate') player.fireRate = Math.max(1, player.fireRate - 1);
            if (key === 'damage') player.damage += 15;
            if (key === 'speed') player.speed += 1.0;
            if (key === 'magnet') player.pickupR += 100;
        }

        function loop() {
            if (!gameActive) return;
            ctx.clearRect(0, 0, w, h);
            frame++;
            camera.update(player.x, player.y);
            drawGrid();
            player.update();
            player.draw();

            if (frame % Math.max(5, 30 - player.lv * 2) === 0) enemies.push(new Enemy());

            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i]; b.update(); b.draw();
                if (b.life <= 0 || Math.hypot(b.x - player.x, b.y - player.y) > 1500) bullets.splice(i, 1);
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i]; e.update(); e.draw();
                if (Math.hypot(player.x - e.x, player.y - e.y) < player.r + e.r) {
                    player.hp -= 0.8;
                    document.body.classList.add('damage-flash');
                    setTimeout(() => document.body.classList.remove('damage-flash'), 50);
                    if (player.hp <= 0) {
                        gameActive = false;
                        document.getElementById('deathMenu').classList.remove('hidden');
                        document.getElementById('finalScore').textContent = `å¾—åˆ†: ${score}`;
                        saveGameProgress(score); // æ­»äº¡æ™‚çµç®—ä¸¦å­˜æª”
                        return;
                    }
                }
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const b = bullets[j];
                    if (Math.hypot(e.x - b.x, e.y - b.y) < e.r + b.r) {
                        e.hp -= b.dmg; bullets.splice(j, 1);
                        if (e.hp <= 0) {
                            score += 10; orbs.push(new Orb(e.x, e.y));
                            enemies.splice(i, 1); break;
                        }
                    }
                }
            }

            for (let i = orbs.length - 1; i >= 0; i--) {
                const o = orbs[i]; o.update(); o.draw();
                if (Math.hypot(player.x - o.x, player.y - o.y) < player.r + o.r) {
                    player.xp += o.val; orbs.splice(i, 1);
                    if (player.xp >= player.nextXp) {
                        player.lv++; player.xp = 0; player.nextXp = Math.floor(player.nextXp * 1.2);
                        showUpgrade(); return;
                    }
                }
            }

            document.getElementById('hpUI').textContent = `HP: ${Math.ceil(player.hp)} / ${player.maxHp}`;
            document.getElementById('scoreUI').textContent = `SCORE: ${score}`;
            document.getElementById('levelUI').textContent = `LEVEL ${player.lv}`;
            document.getElementById('xpBar').style.width = (player.xp / player.nextXp * 100) + '%';
            requestAnimationFrame(loop);
        }

        document.getElementById('btnStart').onclick = () => {
            if (audio.state === 'suspended') audio.resume();
            document.getElementById('startMenu').classList.add('hidden');
            player = new Player();
            gameActive = true;
            loop();
        };
    </script>
</body>
</html>