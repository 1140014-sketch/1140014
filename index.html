<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥µé™å€–å­˜è€…ï¼šèª²é‡‘æˆ°å£«ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f172a; color: #f8fafc; font-family: 'Inter', sans-serif; overflow: hidden; }
        canvas { background-color: #111827; display: block; border-radius: 0.5rem; cursor: crosshair; }
        .hud { position: absolute; pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.5); z-index: 20; }
        
        #xpBarContainer { position: absolute; top: 0; left: 0; width: 100%; height: 8px; background: #1e293b; z-index: 10; }
        #xpBar { width: 0%; height: 100%; background: #3b82f6; transition: width 0.2s; }
        
        .damage-flash { animation: flash 0.15s; }
        @keyframes flash { 0% { background: rgba(220, 38, 38, 0.5); } 100% { background: transparent; } }
        
        .boss-warning { 
            position: absolute; top: 40%; left: 0; width: 100%; text-align: center;
            font-size: 5rem; font-weight: 900; color: #ef4444; z-index: 100;
            pointer-events: none; text-transform: uppercase; letter-spacing: 0.5rem;
            animation: boss-alert 1s infinite alternate; display: none;
        }
        @keyframes boss-alert { 0% { opacity: 0; transform: scale(0.9); } 100% { opacity: 1; transform: scale(1.1); } }
        
        #bossHpContainer { 
            position: absolute; top: 60px; left: 20%; width: 60%; height: 12px; 
            background: #450a0a; border: 2px solid #ef4444; border-radius: 6px; 
            display: none; z-index: 20;
        }
        #bossHpBar { width: 100%; height: 100%; background: #ef4444; transition: width 0.1s; }
        
        .save-indicator { position: fixed; bottom: 1rem; right: 1rem; font-size: 0.75rem; color: #4ade80; opacity: 0; transition: opacity 0.5s; z-index: 100; }
        .modal { backdrop-filter: blur(8px); }
        .scroll-custom::-webkit-scrollbar { width: 6px; }
        .scroll-custom::-webkit-scrollbar-track { background: transparent; }
        .scroll-custom::-webkit-scrollbar-thumb { background: #334155; border-radius: 10px; }

        #btnExitGame { pointer-events: auto; cursor: pointer; }
        .interactive { pointer-events: auto; }
        
        .char-card { transition: all 0.2s; border: 2px solid transparent; }
        .char-card:hover { transform: translateY(-5px); border-color: #3b82f6; }
        .char-card.selected { border-color: #fbbf24; background: rgba(59, 130, 246, 0.2); }
        .char-card.locked { opacity: 0.6; filter: grayscale(1); }
    </style>
</head>
<body class="flex items-center justify-center h-screen m-0">

    <div id="xpBarContainer"><div id="xpBar"></div></div>
    <div id="bossHpContainer"><div id="bossHpBar"></div></div>
    <div id="bossWarning" class="boss-warning">BOSS WARNING</div>
    <div id="saveIndicator" class="save-indicator">é€²åº¦å·²ä¿å­˜...</div>

    <div class="relative w-full h-full">
        <canvas id="gameCanvas"></canvas>
        <div class="hud top-4 left-4 text-green-400 font-bold text-xl" id="hpUI">HP: 100 / 100</div>
        
        <div class="hud top-16 right-4 text-right">
            <div id="scoreUI" class="text-white font-bold text-lg">SCORE: 0</div>
            <div id="coinUI" class="text-yellow-400 font-bold text-lg flex items-center justify-end gap-1">
                <span>$</span> <span id="coinVal">0</span>
            </div>
        </div>
        
        <button id="btnExitGame" onclick="confirmExit()" class="absolute top-4 right-4 bg-red-900/80 hover:bg-red-600 text-white px-4 py-2 rounded-lg border border-red-500/50 transition-colors text-xs font-bold z-50 shadow-lg interactive">
            é€€å‡ºæˆ°é¬¥ âœ•
        </button>

        <div class="hud top-12 left-1/2 -translate-x-1/2 text-center">
            <div id="levelUI" class="text-slate-500 text-xs uppercase">LEVEL 1</div>
        </div>
    </div>

    <!-- åˆå§‹ä¸»é¸å–® -->
    <div id="startMenu" class="absolute inset-0 bg-slate-900/95 flex flex-col items-center justify-center z-50 p-4 modal overflow-y-auto">
        <div class="flex flex-col items-center max-w-4xl w-full">
            <h1 class="text-6xl font-black mb-4 text-blue-500 text-center uppercase tracking-tighter italic">Survivor<br><span class="text-3xl text-yellow-500 not-italic font-sans">Gacha Ops</span></h1>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 w-full mb-8">
                <!-- ç‹€æ…‹æ¬„ -->
                <div class="bg-slate-800 p-6 rounded-2xl border border-slate-700 shadow-xl">
                    <p class="text-slate-500 text-xs uppercase font-bold tracking-widest text-center mb-4">æŒ‡æ®å®˜æª”æ¡ˆ</p>
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-slate-400">æŒæœ‰é‡‘å¹£</span>
                        <span class="text-yellow-400 font-black text-2xl" id="menuCoins">0</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-slate-400">æœ€é«˜å¾—åˆ†</span>
                        <span class="text-white font-bold text-xl" id="menuHighScore">0</span>
                    </div>
                </div>

                <!-- æŠ½å¡/å•†åº—å…¥å£ -->
                <div class="bg-slate-800 p-6 rounded-2xl border border-slate-700 shadow-xl flex flex-col justify-center gap-3">
                    <button id="btnShop" class="w-full bg-yellow-600 hover:bg-yellow-500 py-3 rounded-xl font-bold text-white transition-all">ğŸ›’ è»éœ€åº« (è§’è‰²/æŠ½å¡)</button>
                    <button id="btnLog" class="w-full bg-slate-700 hover:bg-slate-600 py-2 rounded-xl text-sm font-bold text-white transition-all">ğŸ“‹ æ›´æ–°æ—¥èªŒ</button>
                </div>
            </div>

            <div class="flex flex-col w-full max-w-md gap-3">
                <button id="btnStart" class="w-full bg-blue-600 hover:bg-blue-500 px-12 py-5 rounded-2xl text-3xl font-bold transition-all transform hover:scale-105 shadow-lg shadow-blue-500/30 text-white">é–‹å§‹è¡Œå‹•</button>
                <div id="characterSelectInfo" class="text-center text-blue-300 text-sm font-bold mt-2">ç•¶å‰ä½¿ç”¨ï¼šæ¨™æº–ç‰¹ç¨®å…µ</div>
            </div>
        </div>
    </div>

    <!-- è»éœ€åº« (å•†åº—/æŠ½å¡) -->
    <div id="shopModal" class="hidden absolute inset-0 bg-slate-950/95 flex flex-col items-center justify-center z-[60] p-4 modal">
        <div class="w-full max-w-5xl h-[90vh] bg-slate-900 rounded-3xl border border-slate-700 flex flex-col overflow-hidden shadow-2xl relative">
            <!-- é—œé–‰æŒ‰éˆ• -->
            <button id="btnCloseShop" class="absolute top-4 right-4 text-slate-400 hover:text-white text-2xl z-10">âœ•</button>
            
            <div class="flex border-b border-slate-700">
                <button class="flex-1 py-4 text-center font-bold bg-slate-800 text-blue-400" id="tabChars">äººå“¡èª¿åº¦ (Characters)</button>
                <button class="flex-1 py-4 text-center font-bold bg-slate-900 text-slate-500 hover:text-white" id="tabGacha">è£œçµ¦æŠ½ç (Gacha)</button>
            </div>

            <!-- è§’è‰²é é¢ -->
            <div id="panelChars" class="flex-1 p-8 overflow-y-auto scroll-custom">
                <h2 class="text-2xl font-bold text-white mb-6">é¸æ“‡ä½ çš„æˆ°é¬¥äººå“¡</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6" id="charList">
                    <!-- å‹•æ…‹ç”Ÿæˆ -->
                </div>
            </div>

            <!-- æŠ½å¡é é¢ -->
            <div id="panelGacha" class="hidden flex-1 p-8 flex flex-col items-center justify-center relative overflow-hidden">
                <div class="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMiIgY3k9IjIiIHI9IjEiIGZpbGw9InJnYmEoMjU1LDI1NSwyNTUsMC4wNSkiLz48L3N2Zz4=')] opacity-20"></div>
                
                <h2 class="text-3xl font-black text-yellow-400 mb-2">å¹¸é‹è£œçµ¦ç®±</h2>
                <p class="text-slate-400 mb-8">æŠ½å–æ°¸ä¹…å±¬æ€§åŠ æˆ (æ‰€æœ‰è§’è‰²é€šç”¨)</p>
                
                <div class="w-64 h-64 bg-slate-800 rounded-3xl border-4 border-yellow-500 flex items-center justify-center mb-8 shadow-[0_0_50px_rgba(234,179,8,0.2)]">
                    <span class="text-6xl">ğŸ“¦</span>
                </div>

                <div id="gachaResult" class="h-16 text-center mb-4">
                    <p class="text-2xl font-bold text-white animate-bounce hidden" id="gachaText">æ”»æ“ŠåŠ› +1 !</p>
                </div>

                <button id="btnDraw" class="bg-yellow-600 hover:bg-yellow-500 text-white px-12 py-4 rounded-full text-xl font-bold transition-all transform hover:scale-105 shadow-lg disabled:opacity-50 disabled:cursor-not-allowed">
                    æŠ½å–ä¸€æ¬¡ ($1000)
                </button>
                <div class="mt-8 text-left w-full max-w-md bg-slate-800/50 p-4 rounded-xl">
                    <p class="text-xs text-slate-500 font-bold mb-2">ç•¶å‰æ°¸ä¹…åŠ æˆï¼š</p>
                    <div id="statsList" class="grid grid-cols-2 gap-2 text-sm text-slate-300">
                        <!-- æ•¸æ“š -->
                    </div>
                </div>
            </div>

            <div class="p-4 bg-slate-800 border-t border-slate-700 flex justify-between items-center">
                <span class="text-yellow-400 font-bold text-xl ml-4">æŒæœ‰é‡‘å¹£: $<span id="shopCoins">0</span></span>
            </div>
        </div>
    </div>

    <!-- é€€å‡ºç¢ºèªè¦–çª— -->
    <div id="exitModal" class="hidden absolute inset-0 bg-slate-950/80 flex items-center justify-center z-[100] p-4 modal">
        <div class="bg-slate-800 p-8 rounded-3xl border border-red-500/50 w-full max-w-sm shadow-2xl text-center relative">
            <h3 class="text-2xl font-black mb-4 text-white">ç¢ºèªæ’¤é€€ï¼Ÿ</h3>
            <p class="text-slate-400 mb-8 text-sm">æˆ°é¬¥å°‡æœƒæš«åœã€‚è‹¥ç¢ºèªé€€å‡ºï¼Œç•¶å‰é€²åº¦å°‡æœƒéºå¤±ï¼Œåƒ…ä¿å­˜é‡‘å¹£èˆ‡æœ€é«˜åˆ†ã€‚</p>
            <div class="flex gap-4 justify-center">
                <button id="btnExitCancel" class="bg-slate-700 hover:bg-slate-600 text-white px-6 py-3 rounded-xl font-bold transition-colors w-1/2">å–æ¶ˆ</button>
                <button id="btnExitConfirm" class="bg-red-600 hover:bg-red-500 text-white px-6 py-3 rounded-xl font-bold transition-colors w-1/2">ç¢ºèªé€€å‡º</button>
            </div>
        </div>
    </div>

    <!-- æ›´æ–°æ—¥èªŒå½ˆçª— -->
    <div id="logModal" class="hidden absolute inset-0 bg-slate-950/90 flex items-center justify-center z-[60] p-6 modal">
        <div class="bg-slate-800 w-full max-w-lg rounded-3xl border border-slate-700 p-8 shadow-2xl flex flex-col max-h-[80vh]">
            <h2 class="text-2xl font-bold text-blue-400 mb-6 flex items-center gap-2"><span>ğŸ“‹</span> æ›´æ–°æ—¥èªŒ</h2>
            <div class="overflow-y-auto scroll-custom flex-1 space-y-6 pr-2">
                <div class="border-l-4 border-yellow-500 pl-4">
                    <h3 class="font-bold text-white">v2.1.0 - è²¡å¯Œè‡ªç”±</h3>
                    <p class="text-sm text-slate-400">â— æ€ªç‰©æ‰è½èª¿æ•´ï¼šæ¯éš»æ™®é€šæ€ªç‰©å¿…æ‰ $50~$100ã€‚</p>
                    <p class="text-sm text-slate-400">â— BOSS æ“Šæ®ºçå‹µï¼šæ‰è½ $500 å¤§é‡‘å¹£ã€‚</p>
                    <p class="text-sm text-slate-400">â— ä¿®å¾©äº†ä¸€äº› UI é¡¯ç¤ºå•é¡Œã€‚</p>
                </div>
                <div class="border-l-4 border-yellow-500 pl-4">
                    <h3 class="font-bold text-white">v2.0.0 - èª²é‡‘æˆ°å£« (æ¨¡æ“¬)</h3>
                    <p class="text-sm text-slate-400">â— æ–°å¢é‡‘å¹£ç³»çµ±ï¼Œå•†åº—èˆ‡æŠ½å¡åŠŸèƒ½ã€‚</p>
                </div>
            </div>
            <button id="btnCloseLog" class="mt-8 w-full bg-blue-600 hover:bg-blue-500 py-3 rounded-xl font-bold transition-all">è¿”å›é¸å–®</button>
        </div>
    </div>

    <!-- å‡ç´šä»‹é¢ -->
    <div id="upgradeMenu" class="hidden absolute inset-0 bg-slate-950/90 flex flex-col items-center justify-center z-40 modal">
        <h2 class="text-4xl font-black mb-8 text-blue-400 text-center px-4">åŸºå› é‡çµ„ï¼é¸æ“‡é€²åŒ–æ–¹å‘</h2>
        <div id="upgradeOptions" class="flex flex-wrap justify-center gap-6"></div>
    </div>

    <!-- çµæŸä»‹é¢ -->
    <div id="deathMenu" class="hidden absolute inset-0 bg-red-950/90 flex flex-col items-center justify-center z-50 modal">
        <h1 class="text-7xl font-black mb-4 text-white uppercase italic">å­˜æ´»çµ‚æ­¢</h1>
        <p id="finalScore" class="text-3xl mb-2 text-red-200 font-mono">SCORE: 0</p>
        <p class="text-yellow-400 text-xl mb-8 font-bold">+ $<span id="earnedCoins">0</span></p>
        <div class="flex gap-4">
            <button id="btnMenuFromDeath" class="bg-slate-700 hover:bg-slate-600 text-white px-8 py-3 rounded-full text-xl font-bold transition-transform">è¿”å›é¸å–®</button>
            <button onclick="location.reload()" class="bg-white text-red-900 px-12 py-3 rounded-full text-xl font-bold shadow-xl hover:bg-slate-200 transition-transform hover:scale-105">é‡å•Ÿæˆ°å ´</button>
        </div>
    </div>

    <script>
        const SAVE_KEY = 'survivor_game_v2_data';
        let userData = { 
            highScore: 0, 
            coins: 0,
            inventory: ['soldier'], 
            selectedChar: 'soldier',
            gachaStats: { damage: 0, hp: 0, speed: 0, pickup: 0 }
        };

        const CHARACTERS = {
            soldier: { name: "æ¨™æº–ç‰¹ç¨®å…µ", desc: "å¹³è¡¡å‹ï¼Œé©åˆæ–°æ‰‹ã€‚", cost: 0, color: '#3b82f6', hpMod: 1, spdMod: 1, dmgMod: 1 },
            tank: { name: "é‡è£æ©Ÿå…µ", desc: "è¡€é‡æ¥µé«˜ï¼Œè‡ªå¸¶ç·©æ…¢å›è¡€ã€‚", cost: 2000, color: '#10b981', hpMod: 1.5, spdMod: 0.8, dmgMod: 0.9, regen: 0.2 },
            ghost: { name: "å¹½éˆç‰¹å·¥", desc: "æ¥µé€Ÿç§»å‹•ï¼Œé«˜çˆ†æ“Šç‡ã€‚", cost: 3500, color: '#8b5cf6', hpMod: 0.7, spdMod: 1.3, dmgMod: 1.2, crit: 0.2 }
        };

        function loadGameData() {
            const saved = localStorage.getItem(SAVE_KEY);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    userData = { ...userData, ...parsed, gachaStats: { ...userData.gachaStats, ...parsed.gachaStats } };
                } catch(e) { console.error("Save file corrupted"); }
            }
            updateMenuUI();
        }

        function saveGame() {
            localStorage.setItem(SAVE_KEY, JSON.stringify(userData));
            updateMenuUI();
        }

        function updateMenuUI() {
            const menuHighScoreEl = document.getElementById('menuHighScore');
            if(menuHighScoreEl) menuHighScoreEl.textContent = userData.highScore;

            const menuCoinsEl = document.getElementById('menuCoins');
            if(menuCoinsEl) menuCoinsEl.textContent = userData.coins;
            
            const shopCoinsEl = document.getElementById('shopCoins');
            if(shopCoinsEl) shopCoinsEl.textContent = userData.coins;
            
            if (CHARACTERS[userData.selectedChar]) {
                const charName = CHARACTERS[userData.selectedChar].name;
                const charSelectInfo = document.getElementById('characterSelectInfo');
                if(charSelectInfo) charSelectInfo.textContent = `ç•¶å‰ä½¿ç”¨ï¼š${charName}`;
            }
            
            updateStatsDisplay();
            renderCharList();
        }

        function updateStatsDisplay() {
            const list = document.getElementById('statsList');
            const stats = userData.gachaStats;
            if (list) {
                list.innerHTML = `
                    <div>âš”ï¸ å‚·å®³: +${stats.damage}</div>
                    <div>â¤ï¸ è¡€é‡: +${stats.hp}</div>
                    <div>ğŸ‘Ÿ é€Ÿåº¦: +${stats.speed.toFixed(1)}</div>
                    <div>ğŸ§² æ‹¾å–: +${stats.pickup}</div>
                `;
            }
        }

        let gameActive = false;
        let gamePaused = false;
        let sessionCoins = 0; 

        window.confirmExit = () => {
            gamePaused = true;
            document.getElementById('exitModal').classList.remove('hidden');
        };

        window.addEventListener('DOMContentLoaded', () => {
            document.getElementById('btnExitCancel').onclick = () => {
                gamePaused = false;
                document.getElementById('exitModal').classList.add('hidden');
            };

            document.getElementById('btnExitConfirm').onclick = () => {
                gamePaused = false;
                document.getElementById('exitModal').classList.add('hidden');
                endGame(true);
            };

            document.getElementById('btnMenuFromDeath').onclick = returnToMenu;
            document.getElementById('btnLog').onclick = () => document.getElementById('logModal').classList.remove('hidden');
            document.getElementById('btnCloseLog').onclick = () => document.getElementById('logModal').classList.add('hidden');
            
            document.getElementById('btnShop').onclick = openShop;
            document.getElementById('btnCloseShop').onclick = closeShop;
            document.getElementById('tabChars').onclick = () => switchTab('chars');
            document.getElementById('tabGacha').onclick = () => switchTab('gacha');
            document.getElementById('btnDraw').onclick = drawGacha;
            
            const btnStart = document.getElementById('btnStart');
            if (btnStart) {
                btnStart.onclick = () => { 
                    score = 0; sessionCoins = 0; 
                    Object.values(UPGRADES).forEach(u => u.level = 0); 
                    const coinVal = document.getElementById('coinVal');
                    if(coinVal) coinVal.textContent = "0";

                    if (audio.state === 'suspended') audio.resume();
                    document.getElementById('startMenu').classList.add('hidden');
                    
                    player = new Player(); 
                    gameActive = true; 
                    frame = 0;
                    enemies = []; bullets = []; orbs = []; bossBullets = []; medkits = []; coins = []; activeBoss = null;
                    gamePaused = false;
                    loop();
                };
            }

            loadGameData();
        });

        function openShop() {
            document.getElementById('shopModal').classList.remove('hidden');
            switchTab('chars');
        }

        function closeShop() {
            document.getElementById('shopModal').classList.add('hidden');
        }

        function switchTab(tab) {
            const btnChars = document.getElementById('tabChars');
            const btnGacha = document.getElementById('tabGacha');
            const panelChars = document.getElementById('panelChars');
            const panelGacha = document.getElementById('panelGacha');

            if (tab === 'chars') {
                btnChars.className = "flex-1 py-4 text-center font-bold bg-slate-800 text-blue-400";
                btnGacha.className = "flex-1 py-4 text-center font-bold bg-slate-900 text-slate-500 hover:text-white";
                panelChars.classList.remove('hidden');
                panelGacha.classList.add('hidden');
                renderCharList();
            } else {
                btnChars.className = "flex-1 py-4 text-center font-bold bg-slate-900 text-slate-500 hover:text-white";
                btnGacha.className = "flex-1 py-4 text-center font-bold bg-slate-800 text-yellow-400";
                panelChars.classList.add('hidden');
                panelGacha.classList.remove('hidden');
                updateGachaButton();
            }
        }

        function renderCharList() {
            const container = document.getElementById('charList');
            if(!container) return;
            container.innerHTML = '';
            
            Object.keys(CHARACTERS).forEach(key => {
                const char = CHARACTERS[key];
                const isOwned = userData.inventory.includes(key);
                const isSelected = userData.selectedChar === key;
                
                const div = document.createElement('div');
                div.className = `bg-slate-800 p-6 rounded-2xl flex flex-col gap-3 relative char-card ${isSelected ? 'selected' : ''}`;
                if (!isOwned) div.classList.add('locked');

                let actionBtn = '';
                if (isSelected) {
                    actionBtn = `<button class="w-full bg-slate-600 text-white py-2 rounded-lg font-bold cursor-default" disabled>å·²è£å‚™</button>`;
                } else if (isOwned) {
                    actionBtn = `<button onclick="equipChar('${key}')" class="w-full bg-blue-600 hover:bg-blue-500 text-white py-2 rounded-lg font-bold">è£å‚™</button>`;
                } else {
                    const canAfford = userData.coins >= char.cost;
                    actionBtn = `<button onclick="buyChar('${key}')" class="w-full ${canAfford ? 'bg-yellow-600 hover:bg-yellow-500' : 'bg-slate-600 cursor-not-allowed'} text-white py-2 rounded-lg font-bold" ${!canAfford?'disabled':''}>è³¼è²· $${char.cost}</button>`;
                }

                div.innerHTML = `
                    <div class="absolute top-4 right-4 w-4 h-4 rounded-full" style="background:${char.color}"></div>
                    <h3 class="text-xl font-bold text-white">${char.name}</h3>
                    <p class="text-xs text-slate-400 flex-1">${char.desc}</p>
                    <div class="text-xs text-slate-300 space-y-1 my-2">
                        <div class="flex justify-between"><span>HP</span><span class="font-mono">${Math.round(char.hpMod*100)}%</span></div>
                        <div class="flex justify-between"><span>SPD</span><span class="font-mono">${Math.round(char.spdMod*100)}%</span></div>
                        <div class="flex justify-between"><span>DMG</span><span class="font-mono">${Math.round(char.dmgMod*100)}%</span></div>
                    </div>
                    ${actionBtn}
                `;
                container.appendChild(div);
            });
        }

        window.equipChar = (key) => {
            userData.selectedChar = key;
            saveGame();
            renderCharList();
        };

        window.buyChar = (key) => {
            const cost = CHARACTERS[key].cost;
            if (userData.coins >= cost) {
                userData.coins -= cost;
                userData.inventory.push(key);
                userData.selectedChar = key; 
                saveGame();
                renderCharList();
                playSfx(600, 'sine', 0.2);
            }
        };

        function updateGachaButton() {
            const btn = document.getElementById('btnDraw');
            const canAfford = userData.coins >= 1000;
            btn.disabled = !canAfford;
            if (!canAfford) {
                btn.classList.add('bg-slate-600', 'cursor-not-allowed');
                btn.classList.remove('bg-yellow-600', 'hover:bg-yellow-500');
            } else {
                btn.classList.remove('bg-slate-600', 'cursor-not-allowed');
                btn.classList.add('bg-yellow-600', 'hover:bg-yellow-500');
            }
        }

        function drawGacha() {
            if (userData.coins < 1000) return;
            userData.coins -= 1000;
            const types = ['damage', 'hp', 'speed', 'pickup'];
            const type = types[Math.floor(Math.random() * types.length)];
            let val = 0; let text = "";
            if (type === 'damage') { val = 1; text = "æ”»æ“ŠåŠ› +1"; userData.gachaStats.damage += 1; }
            else if (type === 'hp') { val = 10; text = "æœ€å¤§è¡€é‡ +10"; userData.gachaStats.hp += 10; }
            else if (type === 'speed') { val = 0.2; text = "ç§»å‹•é€Ÿåº¦ +0.2"; userData.gachaStats.speed += 0.2; }
            else if (type === 'pickup') { val = 10; text = "æ‹¾å–ç¯„åœ +10"; userData.gachaStats.pickup += 10; }
            const resText = document.getElementById('gachaText');
            resText.textContent = text;
            resText.classList.remove('hidden');
            setTimeout(() => resText.classList.add('hidden'), 2000);
            playSfx(800, 'square', 0.1);
            setTimeout(() => playSfx(1200, 'square', 0.2), 100);
            saveGame();
            updateGachaButton();
            updateStatsDisplay();
        }

        const gameConfig = { width: window.innerWidth, height: window.innerHeight };
        const audio = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(f, t, d, v=0.03) {
            try {
                if (audio.state === 'suspended') audio.resume();
                const o = audio.createOscillator(); const g = audio.createGain();
                o.type = t; o.frequency.setValueAtTime(f, audio.currentTime);
                g.gain.setValueAtTime(v, audio.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audio.currentTime+d);
                o.connect(g); g.connect(audio.destination); o.start(); o.stop(audio.currentTime+d);
            } catch(e) {}
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let player, frame = 0, score = 0, shootTimer = 0, activeBoss = null;
        let enemies = [], bullets = [], orbs = [], bossBullets = [], medkits = [], coins = [];
        let plasmaAngle = 0; 
        
        const camera = {
            x: 0, y: 0, zoom: 1, targetZoom: 1,
            update: function(tx, ty) {
                this.targetZoom = Math.max(0.4, 1 - (player.lv - 1) * 0.04);
                this.zoom += (this.targetZoom - this.zoom) * 0.05;
                this.x = tx - (gameConfig.width / 2) / this.zoom; 
                this.y = ty - (gameConfig.height / 2) / this.zoom;
            },
            toScreen: function(wx, wy) { return { x: (wx - this.x) * this.zoom, y: (wy - this.y) * this.zoom }; }
        };

        const UPGRADES = {
            bullets: { name: "æ¥µé™å½ˆé“", desc: "é¡å¤–å°„æ“Šè·¯ç·š", icon: "ğŸš€", level: 0 },
            fireRate: { name: "è¶…é »é€£ç™¼", desc: "å°„é€Ÿæå‡", icon: "ğŸ”¥", level: 0 },
            damage: { name: "æ¯€æ»…å½ˆé ­", desc: "å‚·å®³åŠ æˆ", icon: "ğŸ’£", level: 0 },
            speed: { name: "é–ƒé›»ç§»å‹•", desc: "ç§»å‹•åŠ é€Ÿ", icon: "ğŸƒ", level: 0 },
            magnet: { name: "å…¨åœ–æ‹¾å–", desc: "ç£åŠ›æ“´å¼µ", icon: "ğŸª", level: 0 },
            regen: { name: "å¥ˆç±³ä¿®å¾©", desc: "æ¯ç§’æ¢å¾©ç”Ÿå‘½", icon: "â¤ï¸", level: 0 }, 
            crit: { name: "å¼±é»åµæ¸¬", desc: "å¢åŠ çˆ†æ“Šæ©Ÿç‡", icon: "ğŸ¯", level: 0 }, 
            plasma: { name: "é›»æ¼¿åŠ›å ´", desc: "å‘¨åœæŒçºŒå‚·å®³", icon: "âš¡", level: 0 } 
        };

        function initCanvas() { gameConfig.width = canvas.width = window.innerWidth; gameConfig.height = canvas.height = window.innerHeight; }
        window.addEventListener('resize', initCanvas); initCanvas();

        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        class Player {
            constructor() {
                const baseChar = CHARACTERS[userData.selectedChar];
                const gacha = userData.gachaStats;

                this.x = 0; this.y = 0; this.r = 15;
                
                this.maxHp = (100 + gacha.hp) * baseChar.hpMod;
                this.hp = this.maxHp;
                this.xp = 0; this.lv = 1; this.nextXp = 50; 
                
                this.speed = (4.5 + gacha.speed) * baseChar.spdMod;
                this.pickupR = (100 + gacha.pickup); 
                this.baseDmg = (25 + gacha.damage) * baseChar.dmgMod;
                
                this.fireRate = 20; 
                this.bulletCount = 1;
                this.regenRate = baseChar.regen || 0;
                this.critChance = baseChar.crit || 0;
                this.plasmaDmg = 0;
                this.plasmaRange = 0;
            }
            update() {
                let currentSpeed = this.speed + (UPGRADES.speed.level * 0.5);
                
                if (keys['KeyW'] || keys['ArrowUp']) this.y -= currentSpeed;
                if (keys['KeyS'] || keys['ArrowDown']) this.y += currentSpeed;
                if (keys['KeyA'] || keys['ArrowLeft']) this.x -= currentSpeed;
                if (keys['KeyD'] || keys['ArrowRight']) this.x += currentSpeed;
                
                let currentFireRate = Math.max(5, this.fireRate - (UPGRADES.fireRate.level * 3));
                shootTimer++; if (shootTimer >= currentFireRate) { this.shoot(); shootTimer = 0; }
                
                let currentRegen = this.regenRate + (UPGRADES.regen.level * 0.5);
                if (frame % 60 === 0 && currentRegen > 0) {
                    this.hp = Math.min(this.maxHp, this.hp + currentRegen);
                }
            }
            shoot() {
                let target = activeBoss || null;
                if (!target) {
                    let minDist = 1000;
                    enemies.forEach(e => { const d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minDist) { minDist = d; target = e; } });
                }
                const angle = target ? Math.atan2(target.y - this.y, target.x - this.x) : -Math.PI/2;
                
                let currentBulletCount = this.bulletCount + UPGRADES.bullets.level;
                let currentDmg = this.baseDmg + (UPGRADES.damage.level * 15);
                let currentCrit = this.critChance + (UPGRADES.crit.level * 0.1);

                for (let i = 0; i < currentBulletCount; i++) {
                    const offset = (i - (currentBulletCount - 1) / 2) * 0.3;
                    let isCrit = Math.random() < currentCrit;
                    let finalDmg = currentDmg * (isCrit ? 2 : 1);
                    bullets.push(new Bullet(this.x, this.y, angle + offset, finalDmg, isCrit));
                }
                playSfx(400, 'square', 0.05, 0.02);
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.save(); ctx.translate(pos.x, pos.y); ctx.scale(camera.zoom, camera.zoom);
                
                let pRange = this.plasmaRange;
                if(UPGRADES.plasma.level > 0) pRange = 150 + UPGRADES.plasma.level * 20;
                
                if (pRange > 0) {
                    ctx.beginPath(); ctx.arc(0, 0, pRange, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(100, 200, 255, 0.1)`; ctx.fill();
                    ctx.strokeStyle = `rgba(100, 200, 255, 0.3)`; ctx.lineWidth = 2; ctx.stroke();
                    ctx.save(); ctx.rotate(plasmaAngle);
                    for(let i=0; i<3; i++) {
                        ctx.rotate(Math.PI*2/3);
                        ctx.beginPath(); ctx.arc(pRange, 0, 5, 0, Math.PI*2); ctx.fillStyle = '#60a5fa'; ctx.fill();
                    }
                    ctx.restore();
                }

                ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI*2);
                ctx.fillStyle = CHARACTERS[userData.selectedChar].color; 
                ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, a, d, isCrit) { 
                this.x = x; this.y = y; this.dmg = d; this.vx = Math.cos(a)*12; this.vy = Math.sin(a)*12; 
                this.r = isCrit ? 6 : 3.5; 
                this.color = isCrit ? '#fca5a5' : '#60a5fa'; 
                this.life = 120;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; }
            draw() { 
                const pos = camera.toScreen(this.x, this.y); 
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2); 
                ctx.fillStyle = this.color; ctx.fill(); 
            }
        }

        class Enemy {
            constructor() {
                const angle = Math.random() * Math.PI * 2;
                this.x = player.x + Math.cos(angle) * (850 / camera.zoom);
                this.y = player.y + Math.sin(angle) * (850 / camera.zoom);
                this.r = 12 + Math.random() * 8; 
                this.hp = (20 + player.lv * 15);
                this.speed = (1.2 + Math.random());
                this.wobbleOffset = Math.random() * 10;
            }
            update() { 
                const angle = Math.atan2(player.y - this.y, player.x - this.x); 
                this.x += Math.cos(angle) * this.speed; 
                this.y += Math.sin(angle) * this.speed; 
            }
            draw() { 
                const pos = camera.toScreen(this.x, this.y); 
                const r = this.r * camera.zoom;
                const wobble = Math.sin(frame * 0.2 + this.wobbleOffset) * (r * 0.15); 
                ctx.save(); ctx.translate(pos.x, pos.y);
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.moveTo(-r, 0); 
                ctx.bezierCurveTo(-r, -r*1.5 + wobble, r, -r*1.5 + wobble, r, 0);
                ctx.quadraticCurveTo(r + wobble, r*0.8, 0, r*0.8);
                ctx.quadraticCurveTo(-r - wobble, r*0.8, -r, 0);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath(); ctx.arc(-r*0.3, -r*0.2 + wobble*0.5, r*0.25, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(r*0.3, -r*0.2 + wobble*0.5, r*0.25, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath(); ctx.arc(-r*0.3, -r*0.2 + wobble*0.5, r*0.1, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(r*0.3, -r*0.2 + wobble*0.5, r*0.1, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }

        class Medkit {
            constructor(x, y) { this.x = x; this.y = y; this.r = 12; this.heal = 30; }
            update() { 
                let pR = player.pickupR + (UPGRADES.magnet.level * 60);
                const d = Math.hypot(player.x - this.x, player.y - this.y); 
                if (d < pR) { const a = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(a)*8; this.y += Math.sin(a)*8; } 
            }
            draw() { const pos = camera.toScreen(this.x, this.y); ctx.save(); ctx.translate(pos.x, pos.y); ctx.scale(camera.zoom, camera.zoom); ctx.fillStyle = '#22c55e'; ctx.beginPath(); ctx.roundRect(-10, -10, 20, 20, 4); ctx.fill(); ctx.fillStyle = 'white'; ctx.fillRect(-2, -7, 4, 14); ctx.fillRect(-7, -2, 14, 4); ctx.restore(); }
        }
        
        class Coin {
            constructor(x, y, v=1) { this.x = x; this.y = y; this.r = 6; this.val = v; }
            update() {
                let pR = player.pickupR + (UPGRADES.magnet.level * 60);
                const d = Math.hypot(player.x - this.x, player.y - this.y);
                if (d < pR) { const a = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(a)*14; this.y += Math.sin(a)*14; }
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.save(); ctx.translate(pos.x, pos.y); ctx.scale(camera.zoom, camera.zoom);
                ctx.fillStyle = '#facc15'; ctx.beginPath(); ctx.arc(0,0, this.r, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#b45309'; ctx.font = 'bold 8px Arial'; ctx.textAlign = 'center'; ctx.textBaseline='middle'; ctx.fillText('$', 0, 1);
                ctx.restore();
            }
        }

        class Boss {
            constructor(lv) {
                this.x = player.x + 600; this.y = player.y; this.r = 80; 
                this.maxHp = 1000 + lv * 600; 
                this.hp = this.maxHp; this.speed = 0.9; this.timer = 0;
            }
            update() { const a = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(a) * this.speed; this.y += Math.sin(a) * this.speed; this.timer++; if (this.timer > 100) { this.attack(); this.timer = 0; } }
            attack() { for (let i=0; i<20; i++) bossBullets.push(new BossBullet(this.x, this.y, (Math.PI*2/20)*i)); }
            draw() { 
                const pos = camera.toScreen(this.x, this.y); 
                const r = this.r * camera.zoom;
                const wobble = Math.sin(frame * 0.1) * (r * 0.1); 
                ctx.save(); ctx.translate(pos.x, pos.y);
                const grad = ctx.createRadialGradient(0, -r*0.5, r*0.2, 0, 0, r);
                grad.addColorStop(0, '#f87171'); grad.addColorStop(1, '#7f1d1d');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.moveTo(-r, 0); 
                ctx.bezierCurveTo(-r, -r*1.6 + wobble, r, -r*1.6 + wobble, r, 0);
                ctx.quadraticCurveTo(r + wobble*0.5, r*0.9, 0, r*0.9);
                ctx.quadraticCurveTo(-r - wobble*0.5, r*0.9, -r, 0);
                ctx.fill(); ctx.lineWidth = 4; ctx.strokeStyle = '#fff'; ctx.stroke();
                ctx.fillStyle = 'white'; ctx.beginPath(); ctx.ellipse(-r*0.3, -r*0.3 + wobble*0.5, r*0.2, r*0.3, -0.2, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(r*0.3, -r*0.3 + wobble*0.5, r*0.2, r*0.3, 0.2, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'red'; 
                ctx.beginPath(); ctx.arc(-r*0.3, -r*0.3 + wobble*0.5, r*0.05, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(r*0.3, -r*0.3 + wobble*0.5, r*0.05, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }

        class BossBullet {
            constructor(x, y, a) { this.x = x; this.y = y; this.vx = Math.cos(a)*5; this.vy = Math.sin(a)*5; this.r = 8; }
            update() { this.x += this.vx; this.y += this.vy; }
            draw() { const pos = camera.toScreen(this.x, this.y); ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2); ctx.fillStyle = '#f87171'; ctx.fill(); }
        }

        class Orb {
            constructor(x, y, v=10) { this.x = x; this.y = y; this.r = 4; this.val = v; }
            update() { 
                let pR = player.pickupR + (UPGRADES.magnet.level * 60);
                const d = Math.hypot(player.x - this.x, player.y - this.y); if (d < pR) { const a = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(a)*10; this.y += Math.sin(a)*10; } 
            }
            draw() { const pos = camera.toScreen(this.x, this.y); ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2); ctx.fillStyle = this.val > 50 ? '#8b5cf6' : '#fbbf24'; ctx.fill(); }
        }

        function loop() {
            if (!gameActive) return;
            if (gamePaused) { requestAnimationFrame(loop); return; }

            ctx.clearRect(0, 0, gameConfig.width, gameConfig.height); frame++; plasmaAngle += 0.05;
            camera.update(player.x, player.y);
            
            ctx.beginPath(); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1;
            const gs = 100 * camera.zoom;
            for (let x = (-camera.x * camera.zoom) % gs; x < gameConfig.width; x += gs) { ctx.moveTo(x, 0); ctx.lineTo(x, gameConfig.height); }
            for (let y = (-camera.y * camera.zoom) % gs; y < gameConfig.height; y += gs) { ctx.moveTo(0, y); ctx.lineTo(gameConfig.width, y); }
            ctx.stroke();

            player.update(); player.draw();

            if (!activeBoss && frame % Math.max(5, 30 - player.lv) === 0) enemies.push(new Enemy());
            if (activeBoss) {
                activeBoss.update(); activeBoss.draw();
                document.getElementById('bossHpBar').style.width = (activeBoss.hp / activeBoss.maxHp * 100) + '%';
            }

            // Collisions
            for (let i = bullets.length-1; i>=0; i--) {
                const b = bullets[i]; b.update(); b.draw();
                if (b.life <= 0) { bullets.splice(i,1); continue; }
                if (activeBoss && Math.hypot(b.x-activeBoss.x, b.y-activeBoss.y) < activeBoss.r+b.r) {
                    activeBoss.hp -= b.dmg; bullets.splice(i,1);
                    if (activeBoss.hp <= 0) { 
                        score += 2000; sessionCoins += 500; // Boss 500 coin
                        coins.push(new Coin(activeBoss.x, activeBoss.y, 500));
                        for(let k=0; k<30; k++) orbs.push(new Orb(activeBoss.x + Math.random()*100-50, activeBoss.y + Math.random()*100-50, 100));
                        medkits.push(new Medkit(activeBoss.x, activeBoss.y)); 
                        activeBoss = null; document.getElementById('bossHpContainer').style.display = 'none'; 
                    }
                    continue;
                }
                for (let j = enemies.length-1; j>=0; j--) {
                    const e = enemies[j];
                    if (Math.hypot(e.x-b.x, e.y-b.y) < e.r+b.r) {
                        e.hp -= b.dmg; bullets.splice(i,1);
                        if (e.hp <= 0) { 
                            score += 15; orbs.push(new Orb(e.x, e.y)); 
                            if (Math.random() < 0.05) medkits.push(new Medkit(e.x, e.y));
                            // æ™®é€šæ€ªç‰©æ‰è½ 50~100 é‡‘å¹£
                            let coinVal = Math.floor(Math.random() * 51) + 50;
                            coins.push(new Coin(e.x, e.y, coinVal));
                            enemies.splice(j,1); 
                        }
                        break;
                    }
                }
            }

            for (let i = enemies.length-1; i>=0; i--) {
                const e = enemies[i]; e.update(); e.draw();
                let pRange = player.plasmaRange; if(UPGRADES.plasma.level > 0) pRange = 150 + UPGRADES.plasma.level * 20;
                if (player.plasmaDmg > 0 && Math.hypot(player.x - e.x, player.y - e.y) < pRange + e.r) {
                    e.hp -= player.plasmaDmg * 0.1; 
                    if (e.hp <= 0) { 
                        score += 15; orbs.push(new Orb(e.x, e.y)); 
                        let coinVal = Math.floor(Math.random() * 51) + 50;
                        coins.push(new Coin(e.x, e.y, coinVal));
                        enemies.splice(i,1); continue; 
                    }
                }
                if (Math.hypot(player.x-e.x, player.y-e.y) < player.r+e.r) {
                    player.hp -= 0.5; document.body.classList.add('damage-flash');
                    setTimeout(() => document.body.classList.remove('damage-flash'), 50);
                }
            }

            for (let i = orbs.length-1; i>=0; i--) {
                const o = orbs[i]; o.update(); o.draw();
                if (Math.hypot(player.x-o.x, player.y-o.y) < player.r+o.r) {
                    player.xp += o.val; orbs.splice(i,1);
                    if (player.xp >= player.nextXp) { player.lv++; player.xp = 0; player.nextXp *= 1.35; showUpgrade(); }
                }
            }

            for (let i = medkits.length-1; i>=0; i--) {
                const m = medkits[i]; m.update(); m.draw();
                if (Math.hypot(player.x-m.x, player.y-m.y) < player.r+m.r) {
                    player.hp = Math.min(player.maxHp, player.hp + m.heal);
                    medkits.splice(i,1); playSfx(800, 'sine', 0.2, 0.05);
                }
            }
            
            for (let i = coins.length-1; i>=0; i--) {
                const c = coins[i]; c.update(); c.draw();
                if (Math.hypot(player.x-c.x, player.y-c.y) < player.r+c.r) {
                    sessionCoins += c.val; coins.splice(i,1); playSfx(1000, 'triangle', 0.1, 0.05);
                    document.getElementById('coinVal').textContent = sessionCoins;
                }
            }

            if (player.hp <= 0) { endGame(false); return; }

            document.getElementById('hpUI').textContent = `HP: ${Math.ceil(player.hp)} / ${player.maxHp}`;
            document.getElementById('scoreUI').textContent = `SCORE: ${score}`;
            document.getElementById('levelUI').textContent = `LEVEL ${player.lv}`;
            document.getElementById('xpBar').style.width = (player.xp / player.nextXp * 100) + '%';
            requestAnimationFrame(loop);
        }

        function returnToMenu() {
            gameActive = false;
            document.getElementById('deathMenu').classList.add('hidden');
            document.getElementById('bossWarning').style.display = 'none';
            document.getElementById('bossHpContainer').style.display = 'none';
            document.getElementById('startMenu').classList.remove('hidden');
            // Reset
            enemies = []; bullets = []; orbs = []; bossBullets = []; medkits = []; coins = []; activeBoss = null;
            loadGameData();
        }

        function endGame(manualExit) {
            gameActive = false; 
            if (manualExit) {
                returnToMenu();
            } else {
                document.getElementById('deathMenu').classList.remove('hidden');
                document.getElementById('finalScore').textContent = `SCORE: ${score}`;
                document.getElementById('earnedCoins').textContent = sessionCoins;
                // æ›´æ–°ç¸½é‡‘å¹£
                userData.coins += sessionCoins;
                saveGame(); // saveGame stores coins
            }
        }

        function showUpgrade() {
            gameActive = false; document.getElementById('upgradeMenu').classList.remove('hidden');
            const options = document.getElementById('upgradeOptions'); options.innerHTML = '';
            const picks = Object.keys(UPGRADES).sort(() => 0.5 - Math.random()).slice(0, 3);
            picks.forEach(key => {
                const up = UPGRADES[key]; const card = document.createElement('div');
                card.className = "bg-slate-800 p-6 rounded-xl border-2 border-slate-700 hover:border-blue-500 cursor-pointer w-48 text-center transition-all hover:scale-105 shadow-lg";
                card.innerHTML = `<div class="text-4xl mb-4">${up.icon}</div><div class="font-bold text-xl mb-2">${up.name}</div><div class="text-xs text-slate-400">${up.desc}</div><div class="mt-4 text-blue-400 font-mono">LV ${up.level}</div>`;
                card.onclick = () => { applyUpgrade(key); document.getElementById('upgradeMenu').classList.add('hidden'); gameActive = true; if (player.lv % 5 === 0 && !activeBoss) spawnBoss(); loop(); };
                options.appendChild(card);
            });
        }

        function applyUpgrade(key) {
            UPGRADES[key].level++;
            playSfx(600, 'sine', 0.2);
        }

        function spawnBoss() {
            document.getElementById('bossWarning').style.display = 'block';
            setTimeout(() => { document.getElementById('bossWarning').style.display = 'none'; activeBoss = new Boss(player.lv); document.getElementById('bossHpContainer').style.display = 'block'; }, 3000);
        }
    </script>
</body>
</html>