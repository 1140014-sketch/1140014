<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>倖存者遊戲 - 無限子彈版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1a202c;
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            background-color: #2d3748;
            display: block;
            border-radius: 0.5rem;
            cursor: crosshair;
        }
        .hud-element {
            position: absolute;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        #saveButton { pointer-events: auto; }
        #xpBarContainer {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            height: 20px;
            background-color: #4a5568;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
            overflow: hidden;
        }
        #xpBar {
            width: 0%;
            height: 100%;
            background-color: #4299e1;
            transition: width 0.3s ease-in-out;
        }
    </style>
</head>
<body class="flex items-center justify-center h-screen m-0">

    <div id="uiContainer" class="relative">
        <canvas id="gameCanvas"></canvas>
        <!-- 遊戲資訊介面 -->
        <div id="healthDisplay" class="hud-element top-4 left-4 text-lg">生命: 100 / 100</div>
        <div id="scoreDisplay" class="hud-element top-4 right-4 text-lg">分數: 0</div>
        <button id="saveButton" class="hud-element top-12 left-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-md text-sm transition duration-300">存檔</button>
        <div id="levelDisplay" class="hud-element bottom-12 left-1/2 -translate-x-1/2 text-lg">等級: 1</div>
        <div id="xpBarContainer">
            <div id="xpBar"></div>
        </div>
        <div id="saveMessage" class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-green-500 text-white font-bold py-3 px-6 rounded-lg z-30">
            遊戲已儲存！
        </div>
    </div>
    
    <!-- 開始遊戲畫面 -->
    <div id="startScreen" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center text-white z-20">
        <h1 class="text-5xl font-bold mb-4">倖存者 - 無限火力和自動吸收</h1>
        <p class="text-xl mb-8">開局即享無限子彈，每 5 秒自動吸收經驗！</p>
        <button id="startButton" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-2xl transition duration-300">啟動無雙模式</button>
        <button id="loadButton" class="mt-4 bg-yellow-500 hover:bg-yellow-700 text-white font-bold py-3 px-6 rounded-lg text-2xl transition duration-300">讀取存檔</button>
    </div>

    <!-- 遊戲結束畫面 -->
    <div id="gameOverScreen" class="hidden absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center text-white z-20">
        <h1 class="text-5xl font-bold mb-4 text-red-500">戰死沙場</h1>
        <p class="text-2xl mb-2">你的最終分數:</p>
        <p id="finalScore" class="text-4xl font-bold mb-8">0</p>
        <button id="restartButton" class="bg-green-500 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-2xl transition duration-300">再次挑戰</button>
    </div>
    
    <!-- 升級畫面 -->
    <div id="levelUpScreen" class="hidden absolute inset-0 bg-black bg-opacity-80 flex-col items-center justify-center text-white z-10">
        <h1 class="text-4xl font-bold mb-8">選擇一個升級！</h1>
        <div id="skillOptions" class="flex gap-6"></div>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const healthDisplay = document.getElementById('healthDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const xpBar = document.getElementById('xpBar');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const levelUpScreen = document.getElementById('levelUpScreen');
        const skillOptions = document.getElementById('skillOptions');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const finalScore = document.getElementById('finalScore');
        const saveButton = document.getElementById('saveButton');
        const loadButton = document.getElementById('loadButton');
        const saveMessage = document.getElementById('saveMessage');

        let animationFrameId;
        let gameRunning = false;
        let gamePaused = false;

        const WORLD_WIDTH = 3000;
        const WORLD_HEIGHT = 3000;
        let camera = { x: 0, y: 0 };

        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.9;
            canvas.height = window.innerHeight * 0.9;
            const uiContainer = document.getElementById('uiContainer');
            uiContainer.style.width = `${canvas.width}px`;
            uiContainer.style.height = `${canvas.height}px`;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        let player, score;
        let projectiles = [], enemies = [], experienceOrbs = [], aoeAttacks = [], turrets = [];
        let enemySpawnInterval, shootInterval, difficultyInterval, aoeInterval, bossWaveInterval, turretInterval, magnetInterval;
        let playerSkills = {};
        let magnetPulse = { active: false, radius: 0, life: 0 };

        const keys = { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false };
        window.addEventListener('keydown', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = true; });
        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });

        function worldToScreen(worldX, worldY) {
            return { x: worldX - camera.x, y: worldY - camera.y };
        }

        class Player {
            constructor(x, y, radius, color, speed) {
                this.x = x; this.y = y; this.radius = radius;
                this.color = color; this.speed = speed;
                this.health = 100; this.maxHealth = 100;
                this.level = 1; this.xp = 0; this.xpToNextLevel = 100;
                this.pickupRadius = 150;
            }
            draw() {
                const screenPos = worldToScreen(this.x, this.y);
                
                if (magnetPulse.active) {
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, magnetPulse.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(66, 153, 225, ${1 - magnetPulse.life / 60})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, this.pickupRadius, 0, Math.PI * 2, false);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.fill();

                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            update() {
                if (gamePaused) return;
                if ((keys.w || keys.ArrowUp) && this.y > 0) this.y -= this.speed;
                if ((keys.s || keys.ArrowDown) && this.y < WORLD_HEIGHT) this.y += this.speed;
                if ((keys.a || keys.ArrowLeft) && this.x > 0) this.x -= this.speed;
                if ((keys.d || keys.ArrowRight) && this.x < WORLD_WIDTH) this.x += this.speed;
                
                camera.x = this.x - canvas.width / 2;
                camera.y = this.y - canvas.height / 2;

                if (magnetPulse.active) {
                    magnetPulse.life++;
                    magnetPulse.radius += 20;
                    if (magnetPulse.life > 60) magnetPulse.active = false;
                }
                
                this.draw();
            }
            gainXP(amount) {
                this.xp += amount;
                if (this.xp >= this.xpToNextLevel) {
                    this.xp -= this.xpToNextLevel;
                    this.level++;
                    this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5);
                    levelUp();
                }
                updateUI();
            }
        }

        class Projectile { 
            constructor(x, y, radius, color, velocity, maxLife = 80, penetration) {
                this.x = x; this.y = y; this.radius = radius;
                this.color = color; this.velocity = velocity;
                this.life = 0; this.maxLife = maxLife;
                this.penetration = penetration; 
                this.hitEnemies = new Set(); 
            }
            draw() {
                const screenPos = worldToScreen(this.x, this.y);
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color; ctx.fill();
            }
            update() { 
                this.x += this.velocity.x; 
                this.y += this.velocity.y; 
                this.life++;
                this.draw(); 
            }
        }

        class Enemy { 
            constructor(x, y, radius, color, speed, health = 1) {
                this.x = x; this.y = y; this.radius = radius;
                this.color = color; this.speed = speed;
                this.health = health; this.maxHealth = health;
            }
            draw() {
                const screenPos = worldToScreen(this.x, this.y);
                if (screenPos.x < -100 || screenPos.x > canvas.width + 100 || screenPos.y < -100 || screenPos.y > canvas.height + 100) return;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color; ctx.fill();
                if (this.maxHealth > 1) {
                    const barWidth = this.radius * 2;
                    const barHeight = 6;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(screenPos.x - this.radius, screenPos.y - this.radius - 15, barWidth, barHeight);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(screenPos.x - this.radius, screenPos.y - this.radius - 15, barWidth * (this.health / this.maxHealth), barHeight);
                }
            }
            update() {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
                this.draw();
            }
        }

        class Boss extends Enemy {
            constructor(x, y, health) {
                super(x, y, 50, 'purple', 0.8, health || 120);
            }
        }
        
        class ExperienceOrb {
            constructor(x, y, radius, color, xpValue) {
                this.x = x; this.y = y; this.radius = radius;
                this.color = color; this.xpValue = xpValue;
                this.beingMagnetized = false;
            }
            draw() {
                const screenPos = worldToScreen(this.x, this.y);
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; ctx.fill();
            }
            update() {
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if (dist < player.pickupRadius || this.beingMagnetized) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const speed = this.beingMagnetized ? 18 : 8;
                    this.x += Math.cos(angle) * speed;
                    this.y += Math.sin(angle) * speed;
                }
                this.draw();
            }
        }
        
        class AoeAttack {
            constructor(x, y, maxRadius, color, duration) {
                this.x = x; this.y = y; this.maxRadius = maxRadius;
                this.color = color; this.duration = duration;
                this.life = 0; this.radius = 0; this.hitEnemies = new Set();
            }
            draw() {
                const screenPos = worldToScreen(this.x, this.y);
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 100, 100, ${1 - this.life / this.duration})`;
                ctx.lineWidth = 4; ctx.stroke();
            }
            update() {
                this.life++;
                this.radius = (this.life / this.duration) * this.maxRadius;
                this.draw();
            }
        }

        class Turret {
            constructor(x, y) {
                this.x = x; this.y = y; this.radius = 20;
                this.color = 'orange';
                this.maxLife = 1800; this.life = this.maxLife;
                this.range = 400;
                this.shootRate = 200; 
                this.shootIntervalId = setInterval(() => this.shoot(), this.shootRate);
            }
            draw() {
                const screenPos = worldToScreen(this.x, this.y);
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3; ctx.stroke();
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, this.radius + 5, -Math.PI / 2, -Math.PI / 2 + (this.life / this.maxLife) * (Math.PI * 2));
                ctx.strokeStyle = 'cyan';
                ctx.lineWidth = 4; ctx.stroke();
            }
            update() { this.life--; this.draw(); }
            shoot() {
                if (gamePaused || enemies.length === 0) return;
                let nearestEnemy = null;
                let minDistance = this.range;
                enemies.forEach(enemy => {
                    const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                    if (dist < minDistance) { minDistance = dist; nearestEnemy = enemy; }
                });
                if (nearestEnemy) {
                    const angle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
                    const velocity = { x: Math.cos(angle) * 8, y: Math.sin(angle) * 8 };
                    projectiles.push(new Projectile(this.x, this.y, 6, 'yellow', velocity, 100, 0));
                }
            }
            destroy() { clearInterval(this.shootIntervalId); }
        }

        const allSkills = {
            increaseFireRate: { name: "提升射速", description: "子彈發射速度提升 15%" },
            increaseMoveSpeed: { name: "提升移速", description: "移動速度提升 10%" },
            addProjectile: { name: "額外子彈", description: "增加一個額外的投射物" },
            aoeDamage: { name: "傷害光環", description: "週期性地對周圍敵人造成傷害" },
            increasePickupRadius: { name: "拾取範圍", description: "拾取範圍擴大 40%" },
            increaseMaxHealth: { name: "增加生命上限", description: "最大生命值提升 25 點" },
            autoTurret: { name: "自動砲台", description: "每5秒在原地安裝一座砲台" },
            bulletPenetration: { name: "子彈穿透", description: "子彈可以多穿透一個敵人" }
        };

        function init(savedState = null) {
            projectiles = []; aoeAttacks = []; turrets = [];
            if (savedState) {
                player = new Player(savedState.player.x, savedState.player.y, savedState.player.radius, savedState.player.color, savedState.player.speed);
                Object.assign(player, savedState.player);
                playerSkills = savedState.playerSkills;
                score = savedState.score;
                enemies = savedState.enemies.map(e => e.type === 'boss' ? new Boss(e.x, e.y, e.health) : new Enemy(e.x, e.y, e.radius, e.color, 1.2, e.health));
                experienceOrbs = savedState.experienceOrbs.map(o => new ExperienceOrb(o.x, o.y, o.radius, o.color, o.xpValue));
            } else {
                player = new Player(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, 15, 'hsl(200, 100%, 50%)', 5);
                enemies = []; experienceOrbs = []; score = 0;
                // --- 無限子彈一開始就有：極高射速與 5 重彈道 ---
                playerSkills = { fireRate: 80, projectiles: 5, projectileRange: 100, penetration: 1 };
            }
            updateUI();
            let spawnRate = 600; 
            [enemySpawnInterval, shootInterval, difficultyInterval, aoeInterval, bossWaveInterval, turretInterval, magnetInterval].forEach(clearInterval);
            enemySpawnInterval = setInterval(spawnEnemy, spawnRate);
            shootInterval = setInterval(shoot, playerSkills.fireRate);
            bossWaveInterval = setInterval(spawnBossWave, 20000);
            magnetInterval = setInterval(triggerMagnet, 5000);

            difficultyInterval = setInterval(() => {
                clearInterval(enemySpawnInterval);
                spawnRate = Math.max(80, spawnRate * 0.8); // 難度提升更快以配合無限子彈
                enemySpawnInterval = setInterval(spawnEnemy, spawnRate);
            }, 10000);
        }

        function triggerMagnet() {
            if (gamePaused || !gameRunning) return;
            magnetPulse.active = true;
            magnetPulse.radius = 0;
            magnetPulse.life = 0;
            experienceOrbs.forEach(orb => orb.beingMagnetized = true);
        }

        function updateUI() {
            healthDisplay.textContent = `生命: ${Math.ceil(player.health)} / ${player.maxHealth}`;
            scoreDisplay.textContent = `分數: ${score}`;
            levelDisplay.textContent = `等級: ${player.level}`;
            xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
        }

        function spawnEnemy() {
             if (gamePaused) return;
             const angle = Math.random() * Math.PI * 2;
             const dist = Math.max(canvas.width, canvas.height) / 1.5 + 100;
             let x = player.x + Math.cos(angle) * dist;
             let y = player.y + Math.sin(angle) * dist;
             x = Math.max(0, Math.min(WORLD_WIDTH, x));
             y = Math.max(0, Math.min(WORLD_HEIGHT, y));
             const radius = Math.random() * 15 + 10;
             const color = `hsl(${Math.random() * 360}, 60%, 60%)`;
             enemies.push(new Enemy(x, y, radius, color, 1.4));
        }
        
        function spawnBossWave() {
            if (gamePaused) return;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const dist = 600;
                enemies.push(new Boss(player.x + Math.cos(angle) * dist, player.y + Math.sin(angle) * dist, 200));
            }
        }

        function shoot() {
             if (gamePaused || enemies.length === 0) return;
             let nearestEnemy = null;
             let minDistance = 800;
             enemies.forEach(enemy => {
                 const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                 if (dist < minDistance) { minDistance = dist; nearestEnemy = enemy; }
             });
             
             if (nearestEnemy) {
                const mainAngle = Math.atan2(nearestEnemy.y - player.y, nearestEnemy.x - player.x);
                const spread = 0.3;
                for (let i = 0; i < playerSkills.projectiles; i++) {
                    const angle = mainAngle + (i - (playerSkills.projectiles - 1) / 2) * spread;
                    const velocity = { x: Math.cos(angle) * 12, y: Math.sin(angle) * 12 };
                    projectiles.push(new Projectile(player.x, player.y, 5, 'cyan', velocity, playerSkills.projectileRange, playerSkills.penetration));
                }
             }
        }

        function levelUp() {
            gamePaused = true;
            skillOptions.innerHTML = '';
            const choices = Object.keys(allSkills).sort(() => 0.5 - Math.random()).slice(0, 3);
            choices.forEach(skillKey => {
                const skill = allSkills[skillKey];
                const btn = document.createElement('button');
                btn.className = "bg-indigo-600 hover:bg-indigo-800 text-white font-bold p-4 rounded-lg w-40 h-40 flex flex-col items-center justify-center text-center text-sm";
                btn.innerHTML = `<span class="text-lg mb-2">${skill.name}</span><span>${skill.description}</span>`;
                btn.onclick = () => { applySkill(skillKey); levelUpScreen.classList.add('hidden'); gamePaused = false; };
                skillOptions.appendChild(btn);
            });
            levelUpScreen.classList.remove('hidden'); levelUpScreen.classList.add('flex');
        }

        function applySkill(key) {
            if (key === 'increaseFireRate') {
                playerSkills.fireRate = Math.max(20, playerSkills.fireRate * 0.8); 
                clearInterval(shootInterval);
                shootInterval = setInterval(shoot, playerSkills.fireRate);
            } else if (key === 'increaseMoveSpeed') player.speed *= 1.1;
            else if (key === 'addProjectile') playerSkills.projectiles += 2;
            else if (key === 'increasePickupRadius') player.pickupRadius *= 1.4;
            else if (key === 'increaseMaxHealth') { player.maxHealth += 25; player.health += 25; updateUI(); }
            else if (key === 'bulletPenetration') playerSkills.penetration += 2;
            else if (key === 'aoeDamage' && !playerSkills.aoe) {
                playerSkills.aoe = true;
                aoeInterval = setInterval(() => { if(!gamePaused) aoeAttacks.push(new AoeAttack(player.x, player.y, 200, 'red', 40)); }, 2000);
            } else if (key === 'autoTurret') {
                turrets.push(new Turret(player.x, player.y));
                if (!playerSkills.turretTimer) {
                    playerSkills.turretTimer = true;
                    turretInterval = setInterval(() => { if(!gamePaused) turrets.push(new Turret(player.x, player.y)); }, 4000);
                }
            }
        }

        function drawGrid() {
            const gridSize = 100; ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)'; ctx.lineWidth = 1;
            const startX = Math.floor(camera.x / gridSize) * gridSize;
            const startY = Math.floor(camera.y / gridSize) * gridSize;
            for (let x = startX; x < camera.x + canvas.width + gridSize; x += gridSize) {
                const screenX = x - camera.x;
                ctx.beginPath(); ctx.moveTo(screenX, 0); ctx.lineTo(screenX, canvas.height); ctx.stroke();
            }
            for (let y = startY; y < camera.y + canvas.height + gridSize; y += gridSize) {
                const screenY = y - camera.y;
                ctx.beginPath(); ctx.moveTo(0, screenY); ctx.lineTo(canvas.width, screenY); ctx.stroke();
            }
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)'; ctx.lineWidth = 5;
            const topLeft = worldToScreen(0, 0);
            ctx.strokeRect(topLeft.x, topLeft.y, WORLD_WIDTH, WORLD_HEIGHT);
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#2d3748'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid(); player.update();
            if (!gamePaused) {
                [projectiles, enemies, experienceOrbs, aoeAttacks, turrets].forEach(arr => arr.forEach(item => item.update()));
                handleCollisions();
                projectiles = projectiles.filter(p => p.life < p.maxLife);
                aoeAttacks = aoeAttacks.filter(a => a.life < a.duration);
                turrets = turrets.filter(t => t.life > 0);
            } else {
                [projectiles, enemies, experienceOrbs, aoeAttacks, turrets].forEach(arr => arr.forEach(item => item.draw()));
            }
        }

        function handleCollisions() {
            experienceOrbs.forEach((orb, i) => {
                if (Math.hypot(player.x - orb.x, player.y - orb.y) < player.radius + orb.radius) {
                    player.gainXP(orb.xpValue); experienceOrbs.splice(i, 1);
                }
            });
            enemies.forEach((enemy, eIdx) => {
                if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < player.radius + enemy.radius) {
                    player.health -= 0.8; updateUI();
                    if (player.health <= 0) endGame();
                }
                projectiles.forEach((proj, pIdx) => {
                    if (!proj.hitEnemies.has(enemy) && Math.hypot(proj.x - enemy.x, proj.y - enemy.y) < proj.radius + enemy.radius) {
                        proj.hitEnemies.add(enemy); enemy.health -= 1;
                        if (proj.penetration > 0) proj.penetration--; else projectiles.splice(pIdx, 1);
                        if (enemy.health <= 0) killEnemy(enemy, eIdx);
                    }
                });
                aoeAttacks.forEach(aoe => {
                    if (!aoe.hitEnemies.has(enemy) && Math.hypot(aoe.x - enemy.x, aoe.y - enemy.y) < aoe.radius + enemy.radius) {
                        aoe.hitEnemies.add(enemy); enemy.health -= 2;
                        if (enemy.health <= 0) killEnemy(enemy, eIdx);
                    }
                });
            });
        }

        function killEnemy(enemy, idx) {
            score += (enemy instanceof Boss ? 1000 : 50);
            experienceOrbs.push(new ExperienceOrb(enemy.x, enemy.y, enemy instanceof Boss ? 12 : 6, enemy instanceof Boss ? 'gold' : '#00f2ff', enemy instanceof Boss ? 200 : 25));
            enemies.splice(idx, 1);
            updateUI();
        }

        function startGame(saved = null) {
            init(saved);
            gameRunning = true; gamePaused = false;
            startScreen.classList.add('hidden'); gameOverScreen.classList.add('hidden');
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animate();
        }

        function endGame() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            [enemySpawnInterval, shootInterval, difficultyInterval, aoeInterval, bossWaveInterval, turretInterval, magnetInterval].forEach(clearInterval);
            finalScore.textContent = score;
            gameOverScreen.classList.remove('hidden'); gameOverScreen.classList.add('flex');
        }

        function saveGame() {
            const data = { player, playerSkills, score, enemies: enemies.map(e => ({x:e.x, y:e.y, radius:e.radius, color:e.color, health:e.health, type: e instanceof Boss ? 'boss' : 'enemy'})), experienceOrbs };
            localStorage.setItem('survivorSaveMap', JSON.stringify(data));
            saveMessage.classList.remove('hidden'); setTimeout(() => saveMessage.classList.add('hidden'), 1500);
        }

        function loadGame() {
            const saved = localStorage.getItem('survivorSaveMap');
            if (saved) startGame(JSON.parse(saved));
        }

        startButton.onclick = () => startGame();
        restartButton.onclick = () => startGame();
        saveButton.onclick = saveGame;
        loadButton.onclick = loadGame;
        if (!localStorage.getItem('survivorSaveMap')) { loadButton.classList.add('opacity-50', 'cursor-not-allowed'); loadButton.disabled = true; }
    </script>
</body>
</html>