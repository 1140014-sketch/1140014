<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥µé™å€–å­˜è€…ï¼šç„¡é™ç«åŠ› - å¸³è™Ÿè¯ç¶²ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f172a; color: #f8fafc; font-family: 'Inter', sans-serif; overflow: hidden; }
        canvas { background-color: #111827; display: block; border-radius: 0.5rem; cursor: crosshair; }
        .hud { position: absolute; pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        #xpBarContainer { position: absolute; top: 0; left: 0; width: 100%; height: 8px; background: #1e293b; z-index: 10; }
        #xpBar { width: 0%; height: 100%; background: #3b82f6; transition: width 0.2s; }
        .damage-flash { animation: flash 0.15s; }
        @keyframes flash { 0% { background: rgba(220, 38, 38, 0.5); } 100% { background: transparent; } }
        
        .boss-warning { 
            position: absolute; top: 40%; left: 0; width: 100%; text-align: center;
            font-size: 5rem; font-weight: 900; color: #ef4444; z-index: 100;
            pointer-events: none; text-transform: uppercase; letter-spacing: 0.5rem;
            animation: boss-alert 1s infinite alternate; display: none;
        }
        @keyframes boss-alert { 0% { opacity: 0; transform: scale(0.9); } 100% { opacity: 1; transform: scale(1.1); } }
        
        .save-indicator { position: fixed; bottom: 1rem; right: 1rem; font-size: 0.75rem; color: #4ade80; opacity: 0; transition: opacity 0.5s; z-index: 100; }
        #bossHpContainer { 
            position: absolute; top: 40px; left: 20%; width: 60%; height: 12px; 
            background: #450a0a; border: 2px solid #ef4444; border-radius: 6px; 
            display: none; z-index: 20;
        }
        #bossHpBar { width: 100%; height: 100%; background: #ef4444; transition: width 0.1s; }
        
        .custom-scroll::-webkit-scrollbar { width: 4px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #334155; border-radius: 10px; }

        /* ä¿®å¾© Modal é¡¯ç¤ºå•é¡Œ */
        #authModal { z-index: 9999; }
    </style>
</head>
<body class="flex items-center justify-center h-screen m-0">

    <div id="xpBarContainer"><div id="xpBar"></div></div>
    <div id="bossHpContainer"><div id="bossHpBar"></div></div>
    <div id="bossWarning" class="boss-warning">BOSS WARNING</div>
    <div id="saveIndicator" class="save-indicator">æ•¸æ“šå·²åŒæ­¥è‡³é›²ç«¯...</div>

    <div class="relative w-full h-full">
        <canvas id="gameCanvas"></canvas>
        <div class="hud top-4 left-4 text-green-400 font-bold" id="hpUI">HP: 100 / 100</div>
        <div class="hud top-4 right-4 text-yellow-400 font-bold" id="scoreUI">SCORE: 0</div>
        <div class="hud top-12 left-1/2 -translate-x-1/2 text-slate-500 text-xs" id="levelUI">LEVEL 1</div>
    </div>

    <!-- åˆå§‹ä¸»é¸å–® -->
    <div id="startMenu" class="absolute inset-0 bg-slate-900/95 flex flex-col md:flex-row items-center justify-center z-50 p-8 gap-8">
        <div class="flex flex-col items-center max-w-md w-full">
            <h1 class="text-5xl font-black mb-2 text-blue-500 text-center uppercase tracking-tighter italic">Survivor<br><span class="text-2xl text-red-500 not-italic">Elite Ops Online</span></h1>
            
            <!-- å¸³è™Ÿè³‡è¨Šå€ -->
            <div id="userStats" class="mb-6 w-full bg-slate-800 p-5 rounded-2xl border border-slate-700 shadow-xl">
                <div class="flex justify-between items-start mb-4">
                    <div class="text-left">
                        <p class="text-slate-500 text-[10px] uppercase font-bold tracking-widest">ç‰¹ç¨®å…µç·¨è™Ÿ</p>
                        <p id="userIdDisplay" class="text-slate-300 font-mono text-xs truncate w-32">è¼‰å…¥ä¸­...</p>
                    </div>
                    <button id="authBtn" class="text-[10px] bg-slate-700 hover:bg-blue-600 px-2 py-1 rounded transition-colors uppercase font-bold">ç™»å…¥/è¨»å†Š</button>
                </div>
                <div class="flex justify-around items-center border-t border-slate-700 pt-4">
                    <div class="text-center">
                        <p class="text-slate-500 text-[10px]">é›²ç«¯æœ€é«˜åˆ†</p>
                        <p id="highScoreText" class="text-yellow-400 font-black text-xl">0</p>
                    </div>
                    <div class="text-center">
                        <p class="text-slate-500 text-[10px]">ç›®å‰ç‹€æ…‹</p>
                        <p id="authStatusText" class="text-green-500 text-xs font-bold">æƒæä¸­...</p>
                    </div>
                </div>
            </div>

            <button id="btnStart" class="w-full bg-blue-600 hover:bg-blue-500 px-12 py-4 rounded-full text-2xl font-bold transition-all transform hover:scale-105 shadow-lg shadow-blue-500/50 mb-4">é–‹å§‹ä½œæˆ°</button>
            <p class="text-slate-500 text-xs">å–®ç™¼æ­¥æ§å•Ÿå‹•ã€‚æˆ°å ´å‡ç´šå¯è§£é–å¤šé‡å½ˆé“ã€‚</p>
        </div>

        <!-- æ’è¡Œæ¦œ -->
        <div class="bg-slate-800/50 border border-slate-700 rounded-2xl w-full max-w-xs h-[400px] flex flex-col overflow-hidden">
            <div class="bg-slate-700/50 p-3 text-center font-bold text-sm border-b border-slate-600">å…¨çƒè‹±é›„æ¦œ (TOP 20)</div>
            <div id="leaderboardList" class="flex-1 overflow-y-auto p-2 custom-scroll space-y-2">
                <div class="text-center text-slate-500 py-10 text-xs animate-pulse">é€£ç·šè‡³æˆ°ç•¥æŒ‡æ®éƒ¨...</div>
            </div>
        </div>
    </div>

    <!-- ç™»å…¥è¦–çª— -->
    <div id="authModal" class="hidden absolute inset-0 bg-slate-950/80 flex items-center justify-center p-4">
        <div class="bg-slate-800 p-8 rounded-3xl border border-slate-700 w-full max-w-sm shadow-2xl relative">
            <h3 id="modalTitle" class="text-2xl font-bold mb-6 text-center">è»äº‹åŸºåœ°å‡†å…¥</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-[10px] text-slate-500 mb-1 uppercase">é›»å­éƒµä»¶</label>
                    <input type="email" id="emailInput" class="w-full bg-slate-900 border border-slate-700 rounded-lg p-3 text-sm focus:outline-none focus:border-blue-500 text-white" placeholder="pilot@elite.ops">
                </div>
                <div>
                    <label class="block text-[10px] text-slate-500 mb-1 uppercase">é€šè¨Šå¯†ç¢¼</label>
                    <input type="password" id="passwordInput" class="w-full bg-slate-900 border border-slate-700 rounded-lg p-3 text-sm focus:outline-none focus:border-blue-500 text-white" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢">
                </div>
                <div id="authError" class="text-red-500 text-[10px] text-center hidden"></div>
                <button id="submitAuth" class="w-full bg-blue-600 hover:bg-blue-500 py-3 rounded-lg font-bold transition-colors mt-4">ç¢ºèªèº«åˆ†</button>
                <button id="toggleAuthMode" class="w-full text-slate-500 text-[10px] hover:text-slate-300">é‚„æ²’æœ‰å¸³è™Ÿï¼Ÿç”³è«‹åŠ å…¥ç‰¹ç¨®éƒ¨éšŠ</button>
                <button id="closeAuth" class="w-full text-slate-600 text-[10px] pt-2">å–æ¶ˆä¸¦ä»¥è¨ªå®¢èº«åˆ†ç¹¼çºŒ</button>
            </div>
        </div>
    </div>

    <!-- å‡ç´šä»‹é¢ -->
    <div id="upgradeMenu" class="hidden absolute inset-0 bg-slate-950/90 flex flex-col items-center justify-center z-40">
        <h2 class="text-4xl font-black mb-8 text-blue-400">ç«åŠ›é€²éšï¼é¸æ“‡æ›´å¼·çš„å¼·åŒ–</h2>
        <div id="upgradeOptions" class="flex gap-6"></div>
    </div>

    <!-- çµæŸä»‹é¢ -->
    <div id="deathMenu" class="hidden absolute inset-0 bg-red-950/90 flex flex-col items-center justify-center z-50">
        <h1 class="text-6xl font-black mb-4 text-white uppercase italic">K.I.A.</h1>
        <p id="finalScore" class="text-2xl mb-2 text-red-200 font-mono">SCORE: 0</p>
        <p id="newRecordText" class="text-yellow-400 font-bold mb-8 opacity-0">NEW WORLD RECORD!</p>
        <button onclick="location.reload()" class="bg-white text-red-900 px-10 py-3 rounded-full font-bold shadow-xl hover:bg-slate-200">é‡è¿”æˆ°å ´</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase åˆå§‹åŒ– ---
        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'survivor-elite-v3';

        let currentUser = null;
        let userSaveData = { highScore: 0 };
        let isSignUpMode = false;

        // --- æ ¸å¿ƒé‚è¼¯ä¿®æ­£ï¼šç­‰å¾… DOM è¼‰å…¥å¾Œç¶å®š ---
        window.addEventListener('DOMContentLoaded', () => {
            const authModal = document.getElementById('authModal');
            const authBtn = document.getElementById('authBtn');
            const toggleAuthMode = document.getElementById('toggleAuthMode');
            const submitAuth = document.getElementById('submitAuth');
            const closeAuth = document.getElementById('closeAuth');

            // ç™»å…¥æŒ‰éˆ•é»æ“Š
            authBtn.onclick = (e) => {
                e.stopPropagation();
                if (currentUser && !currentUser.isAnonymous) {
                    signOut(auth).then(() => {
                        window.location.reload(); // ç™»å‡ºå¾Œåˆ·æ–°ä»¥æ¢å¾©è¨ªå®¢ç‹€æ…‹
                    });
                } else {
                    authModal.classList.remove('hidden');
                }
            };

            // é—œé–‰è¦–çª—
            closeAuth.onclick = () => authModal.classList.add('hidden');

            // åˆ‡æ› è¨»å†Š/ç™»å…¥ æ¨¡å¼
            toggleAuthMode.onclick = () => {
                isSignUpMode = !isSignUpMode;
                document.getElementById('modalTitle').textContent = isSignUpMode ? "ç”³è«‹åŠ å…¥éƒ¨éšŠ" : "è»äº‹åŸºåœ°å‡†å…¥";
                submitAuth.textContent = isSignUpMode ? "å®Œæˆè¨»å†Š" : "ç¢ºèªèº«åˆ†";
                toggleAuthMode.textContent = isSignUpMode ? "å·²æœ‰ç·¨è™Ÿï¼Ÿç›´æ¥ç™»å…¥" : "é‚„æ²’æœ‰å¸³è™Ÿï¼Ÿç”³è«‹åŠ å…¥ç‰¹ç¨®éƒ¨éšŠ";
            };

            // æäº¤è¡¨å–®
            submitAuth.onclick = async () => {
                const email = document.getElementById('emailInput').value;
                const pass = document.getElementById('passwordInput').value;
                const errorEl = document.getElementById('authError');
                
                if(!email || !pass) {
                    errorEl.textContent = "è«‹è¼¸å…¥å®Œæ•´é›»éƒµèˆ‡å¯†ç¢¼";
                    errorEl.classList.remove('hidden');
                    return;
                }

                errorEl.classList.add('hidden');
                submitAuth.disabled = true;
                submitAuth.textContent = "é©—è­‰ä¸­...";

                try {
                    if (isSignUpMode) {
                        await createUserWithEmailAndPassword(auth, email, pass);
                    } else {
                        await signInWithEmailAndPassword(auth, email, pass);
                    }
                    authModal.classList.add('hidden');
                } catch (error) {
                    console.error("Auth Error:", error);
                    errorEl.textContent = "èªè­‰å¤±æ•—ï¼šéƒµä»¶å·²ä½¿ç”¨æˆ–å¯†ç¢¼å¤ªçŸ­";
                    errorEl.classList.remove('hidden');
                } finally {
                    submitAuth.disabled = false;
                    submitAuth.textContent = isSignUpMode ? "å®Œæˆè¨»å†Š" : "ç¢ºèªèº«åˆ†";
                }
            };
        });

        // --- å¸³è™Ÿç³»çµ±é‚è¼¯ ---
        const initAuth = async () => {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token).catch(() => signInAnonymously(auth));
            } else {
                await signInAnonymously(auth);
            }
        };

        onAuthStateChanged(auth, async (user) => {
            currentUser = user;
            if (user) {
                const isAnonymous = user.isAnonymous;
                document.getElementById('userIdDisplay').textContent = user.uid;
                document.getElementById('authStatusText').textContent = isAnonymous ? "è¨ªå®¢æ¨¡å¼" : "æ­£å¼æˆå“¡";
                document.getElementById('authStatusText').className = isAnonymous ? "text-slate-500 text-xs font-bold" : "text-blue-400 text-xs font-bold";
                document.getElementById('authBtn').textContent = isAnonymous ? "ç™»å…¥/è¨»å†Š" : "ç™»å‡ºå¸³è™Ÿ";
                
                await loadGameProgress();
                setupLeaderboardListener();
            }
        });

        initAuth();

        async function loadGameProgress() {
            if (!currentUser) return;
            const docRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saveData', 'progress');
            try {
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) { 
                    userSaveData = docSnap.data(); 
                } else { 
                    await setDoc(docRef, userSaveData); 
                }
                document.getElementById('highScoreText').textContent = userSaveData.highScore || 0;
            } catch (e) { console.error(e); }
        }

        // --- æ’è¡Œæ¦œç›£è½ ---
        function setupLeaderboardListener() {
            const leaderboardCol = collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
            onSnapshot(leaderboardCol, (snapshot) => {
                const listEl = document.getElementById('leaderboardList');
                let scores = [];
                snapshot.forEach(doc => scores.push(doc.data()));
                scores.sort((a, b) => b.score - a.score);
                scores = scores.slice(0, 20);
                listEl.innerHTML = '';
                scores.forEach((item, idx) => {
                    const isMe = currentUser && item.uid === currentUser.uid;
                    const row = document.createElement('div');
                    row.className = `flex items-center justify-between p-2 rounded-lg text-xs ${isMe ? 'bg-blue-900/40 border border-blue-500/50' : 'bg-slate-700/30'}`;
                    row.innerHTML = `<div class="flex items-center gap-2 truncate"><span class="font-bold w-4 text-slate-500">${idx+1}</span><span class="truncate text-slate-300 font-mono">${item.uid.substring(0,8)}</span></div><span class="font-bold text-blue-400">${item.score}</span>`;
                    listEl.appendChild(row);
                });
            }, (err) => console.log(err));
        }

        async function saveGameProgress(newScore) {
            if (!currentUser) return;
            const docRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saveData', 'progress');
            if (newScore > (userSaveData.highScore || 0)) {
                userSaveData.highScore = newScore;
                document.getElementById('newRecordText').style.opacity = 1;
                try {
                    await setDoc(docRef, { highScore: newScore }, { merge: true });
                    const leaderboardDoc = doc(db, 'artifacts', appId, 'public', 'data', 'leaderboard', currentUser.uid);
                    await setDoc(leaderboardDoc, { uid: currentUser.uid, score: newScore, updatedAt: Date.now() });
                    showSaveIndicator();
                } catch (e) { console.error(e); }
            }
        }

        function showSaveIndicator() {
            const el = document.getElementById('saveIndicator');
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 2000);
        }

        // --- éŠæˆ²å¼•æ“èˆ‡æ¸²æŸ“é‚è¼¯ (ä¿æŒä¸è®Š) ---
        const audio = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(f, t, d, v=0.03) {
            try {
                if (audio.state === 'suspended') audio.resume();
                const o = audio.createOscillator(); const g = audio.createGain();
                o.type = t; o.frequency.setValueAtTime(f, audio.currentTime);
                g.gain.setValueAtTime(v, audio.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audio.currentTime+d);
                o.connect(g); g.connect(audio.destination); o.start(); o.stop(audio.currentTime+d);
            } catch(e) {}
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let w, h, player, gameActive = false, frame = 0, score = 0, shootTimer = 0, activeBoss = null;
        let enemies = [], bullets = [], orbs = [], bossBullets = [];

        const camera = {
            x: 0, y: 0, zoom: 1, targetZoom: 1,
            update: function(tx, ty) {
                this.targetZoom = Math.max(0.4, 1 - (player.lv - 1) * 0.04);
                this.zoom += (this.targetZoom - this.zoom) * 0.05;
                this.x = tx - (w/2)/this.zoom; this.y = ty - (h/2)/this.zoom;
            },
            toScreen: function(wx, wy) { return { x: (wx - this.x) * this.zoom, y: (wy - this.y) * this.zoom }; }
        };

        const UPGRADES = {
            bullets: { name: "æ¥µé™å½ˆé“", desc: "é¡å¤–å°„æ“Šè·¯ç·š", icon: "ğŸš€", level: 0, max: 20 },
            fireRate: { name: "è¶…é »é€£ç™¼", desc: "å°„é€Ÿæå‡", icon: "ğŸ”¥", level: 0, max: 20 },
            damage: { name: "æ¯€æ»…å½ˆé ­", desc: "å‚·å®³åŠ æˆ", icon: "ğŸ’£", level: 0, max: 20 },
            speed: { name: "é–ƒé›»ç§»å‹•", desc: "ç§»å‹•åŠ é€Ÿ", icon: "ğŸƒ", level: 0, max: 10 },
            magnet: { name: "å…¨åœ–æ‹¾å–", desc: "ç£åŠ›æ“´å¼µ", icon: "ğŸª", level: 0, max: 10 }
        };

        function initCanvas() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; }
        window.addEventListener('resize', initCanvas); initCanvas();

        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        class Player {
            constructor() {
                this.x = 0; this.y = 0; this.r = 15; this.hp = 100; this.maxHp = 100;
                this.xp = 0; this.lv = 1; this.nextXp = 50; this.speed = 4.5;
                this.pickupR = 100; this.damage = 25; this.fireRate = 20; this.bulletCount = 1;
            }
            update() {
                if (keys['KeyW'] || keys['ArrowUp']) this.y -= this.speed;
                if (keys['KeyS'] || keys['ArrowDown']) this.y += this.speed;
                if (keys['KeyA'] || keys['ArrowLeft']) this.x -= this.speed;
                if (keys['KeyD'] || keys['ArrowRight']) this.x += this.speed;
                shootTimer++; if (shootTimer >= this.fireRate) { this.shoot(); shootTimer = 0; }
            }
            shoot() {
                let target = activeBoss || null;
                if (!target) {
                    let minDist = 1000;
                    enemies.forEach(e => {
                        const d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < minDist) { minDist = d; target = e; }
                    });
                }
                const angle = target ? Math.atan2(target.y - this.y, target.x - this.x) : -Math.PI/2;
                for (let i = 0; i < this.bulletCount; i++) {
                    const offset = (i - (this.bulletCount - 1) / 2) * 0.3;
                    bullets.push(new Bullet(this.x, this.y, angle + offset, this.damage));
                }
                playSfx(400, 'square', 0.05, 0.02);
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.save(); ctx.translate(pos.x, pos.y); ctx.scale(camera.zoom, camera.zoom);
                ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI*2);
                ctx.fillStyle = '#3b82f6'; ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, a, d) {
                this.x = x; this.y = y; this.dmg = d;
                this.vx = Math.cos(a) * 12; this.vy = Math.sin(a) * 12; this.r = 3.5;
            }
            update() { this.x += this.vx; this.y += this.vy; }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = '#60a5fa'; ctx.fill();
            }
        }

        class Enemy {
            constructor() {
                const angle = Math.random() * Math.PI * 2;
                this.x = player.x + Math.cos(angle) * (850 / camera.zoom);
                this.y = player.y + Math.sin(angle) * (850 / camera.zoom);
                this.r = 12 + Math.random() * 8; this.hp = 20 + player.lv * 12; this.speed = 1.2 + Math.random();
            }
            update() {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed; this.y += Math.sin(angle) * this.speed;
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = '#ef4444'; ctx.fill();
            }
        }

        class Boss {
            constructor(lv) {
                this.x = player.x + 600; this.y = player.y; this.r = 60;
                this.maxHp = 2500 + lv * 1200; this.hp = this.maxHp; this.speed = 0.9; this.timer = 0;
            }
            update() {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed; this.y += Math.sin(angle) * this.speed;
                this.timer++; if (this.timer > 100) { this.attack(); this.timer = 0; }
            }
            attack() {
                for (let i=0; i<20; i++) bossBullets.push(new BossBullet(this.x, this.y, (Math.PI*2/20)*i));
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.save(); ctx.translate(pos.x, pos.y); ctx.scale(camera.zoom, camera.zoom);
                ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI*2);
                ctx.fillStyle = '#7f1d1d'; ctx.fill(); ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 4; ctx.stroke();
                ctx.restore();
            }
        }

        class BossBullet {
            constructor(x, y, a) {
                this.x = x; this.y = y; this.vx = Math.cos(a)*5; this.vy = Math.sin(a)*5; this.r = 8;
            }
            update() { this.x += this.vx; this.y += this.vy; }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = '#f87171'; ctx.fill();
            }
        }

        class Orb {
            constructor(x, y, v=10) { this.x = x; this.y = y; this.r = 4; this.val = v; }
            update() {
                const d = Math.hypot(player.x - this.x, player.y - this.y);
                if (d < player.pickupR) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x += Math.cos(angle)*10; this.y += Math.sin(angle)*10;
                }
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = this.val > 50 ? '#8b5cf6' : '#fbbf24'; ctx.fill();
            }
        }

        function loop() {
            if (!gameActive) return;
            ctx.clearRect(0, 0, w, h); frame++; camera.update(player.x, player.y);
            
            // Grid
            ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1;
            const gs = 100 * camera.zoom;
            for (let x = (-camera.x * camera.zoom) % gs; x < w; x += gs) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
            for (let y = (-camera.y * camera.zoom) % gs; y < h; y += gs) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
            ctx.stroke();

            player.update(); player.draw();

            if (!activeBoss && frame % Math.max(5, 30 - player.lv) === 0) enemies.push(new Enemy());
            if (activeBoss) {
                activeBoss.update(); activeBoss.draw();
                document.getElementById('bossHpBar').style.width = (activeBoss.hp / activeBoss.maxHp * 100) + '%';
            }

            for (let i = bullets.length-1; i>=0; i--) {
                const b = bullets[i]; b.update(); b.draw();
                if (activeBoss && Math.hypot(b.x-activeBoss.x, b.y-activeBoss.y) < activeBoss.r+b.r) {
                    activeBoss.hp -= b.dmg; bullets.splice(i,1);
                    if (activeBoss.hp <= 0) { 
                        score += 1000; activeBoss = null; 
                        document.getElementById('bossHpContainer').style.display = 'none';
                    }
                    continue;
                }
                for (let j = enemies.length-1; j>=0; j--) {
                    const e = enemies[j];
                    if (Math.hypot(e.x-b.x, e.y-b.y) < e.r+b.r) {
                        e.hp -= b.dmg; bullets.splice(i,1);
                        if (e.hp <= 0) { score += 15; orbs.push(new Orb(e.x, e.y)); enemies.splice(j,1); }
                        break;
                    }
                }
            }

            for (let i = enemies.length-1; i>=0; i--) {
                const e = enemies[i]; e.update(); e.draw();
                if (Math.hypot(player.x-e.x, player.y-e.y) < player.r+e.r) {
                    player.hp -= 0.5; document.body.classList.add('damage-flash');
                    setTimeout(() => document.body.classList.remove('damage-flash'), 50);
                }
            }

            for (let i = orbs.length-1; i>=0; i--) {
                const o = orbs[i]; o.update(); o.draw();
                if (Math.hypot(player.x-o.x, player.y-o.y) < player.r+o.r) {
                    player.xp += o.val; orbs.splice(i,1);
                    if (player.xp >= player.nextXp) {
                        player.lv++; player.xp = 0; player.nextXp *= 1.35;
                        showUpgrade(); return;
                    }
                }
            }

            if (player.hp <= 0) {
                gameActive = false; document.getElementById('deathMenu').classList.remove('hidden');
                document.getElementById('finalScore').textContent = `SCORE: ${score}`;
                saveGameProgress(score); return;
            }

            document.getElementById('hpUI').textContent = `HP: ${Math.ceil(player.hp)} / ${player.maxHp}`;
            document.getElementById('scoreUI').textContent = `SCORE: ${score}`;
            document.getElementById('levelUI').textContent = `LEVEL ${player.lv}`;
            document.getElementById('xpBar').style.width = (player.xp / player.nextXp * 100) + '%';
            requestAnimationFrame(loop);
        }

        function showUpgrade() {
            gameActive = false; document.getElementById('upgradeMenu').classList.remove('hidden');
            const options = document.getElementById('upgradeOptions'); options.innerHTML = '';
            const picks = Object.keys(UPGRADES).sort(() => 0.5 - Math.random()).slice(0, 3);
            picks.forEach(key => {
                const up = UPGRADES[key];
                const card = document.createElement('div');
                card.className = "bg-slate-800 p-6 rounded-xl border-2 border-slate-700 hover:border-blue-500 cursor-pointer w-48 text-center transition-all hover:scale-105 shadow-lg";
                card.innerHTML = `<div class="text-4xl mb-4">${up.icon}</div><div class="font-bold text-xl mb-2">${up.name}</div><div class="text-xs text-slate-400">${up.desc}</div><div class="mt-4 text-blue-400 font-mono">LV ${up.level}</div>`;
                card.onclick = () => { applyUpgrade(key); document.getElementById('upgradeMenu').classList.add('hidden'); gameActive = true; if (player.lv % 5 === 0 && !activeBoss) spawnBoss(); loop(); };
                options.appendChild(card);
            });
        }

        function spawnBoss() {
            document.getElementById('bossWarning').style.display = 'block';
            setTimeout(() => {
                document.getElementById('bossWarning').style.display = 'none';
                activeBoss = new Boss(player.lv); document.getElementById('bossHpContainer').style.display = 'block';
            }, 3000);
        }

        function applyUpgrade(key) {
            UPGRADES[key].level++;
            if (key === 'bullets') player.bulletCount++;
            if (key === 'fireRate') player.fireRate = Math.max(5, player.fireRate - 3);
            if (key === 'damage') player.damage += 15;
            if (key === 'speed') player.speed += 0.5;
            if (key === 'magnet') player.pickupR += 60;
            playSfx(600, 'sine', 0.2);
        }

        document.getElementById('btnStart').onclick = () => {
            if (audio.state === 'suspended') audio.resume();
            document.getElementById('startMenu').classList.add('hidden');
            player = new Player(); gameActive = true; loop();
        };
    </script>
</body>
</html>