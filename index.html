<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥µé™å€–å­˜è€…ï¼šç„¡é™ç«åŠ› - BOSS é™è‡¨ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f172a; color: #f8fafc; font-family: 'Inter', sans-serif; overflow: hidden; }
        canvas { background-color: #111827; display: block; border-radius: 0.5rem; cursor: crosshair; }
        .hud { position: absolute; pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        #xpBarContainer {
            position: absolute; top: 0; left: 0; width: 100%; height: 8px;
            background: #1e293b; z-index: 10;
        }
        #xpBar { width: 0%; height: 100%; background: #3b82f6; transition: width 0.2s; }
        .damage-flash { animation: flash 0.15s; }
        @keyframes flash { 0% { background: rgba(220, 38, 38, 0.5); } 100% { background: transparent; } }
        
        /* BOSS è­¦å‘Šå‹•ç•« */
        .boss-warning { 
            position: absolute; top: 40%; left: 0; width: 100%; text-align: center;
            font-size: 5rem; font-weight: 900; color: #ef4444; z-index: 100;
            pointer-events: none; text-transform: uppercase; letter-spacing: 0.5rem;
            animation: boss-alert 1s infinite alternate;
            display: none;
        }
        @keyframes boss-alert { 0% { opacity: 0; transform: scale(0.9); } 100% { opacity: 1; transform: scale(1.1); } }
        
        .save-indicator { position: fixed; bottom: 1rem; right: 1rem; font-size: 0.75rem; color: #4ade80; opacity: 0; transition: opacity 0.5s; }
        #bossHpContainer { 
            position: absolute; top: 40px; left: 20%; width: 60%; height: 12px; 
            background: #450a0a; border: 2px solid #ef4444; border-radius: 6px; 
            display: none; z-index: 20;
        }
        #bossHpBar { width: 100%; height: 100%; background: #ef4444; transition: width 0.1s; }
    </style>
</head>
<body class="flex items-center justify-center h-screen m-0">

    <div id="xpBarContainer"><div id="xpBar"></div></div>
    <div id="bossHpContainer"><div id="bossHpBar"></div></div>
    <div id="bossWarning" class="boss-warning">BOSS WARNING</div>
    <div id="saveIndicator" class="save-indicator">å·²åŒæ­¥é›²ç«¯é€²åº¦...</div>

    <div class="relative w-full h-full">
        <canvas id="gameCanvas"></canvas>
        <div class="hud top-4 left-4 text-green-400 font-bold" id="hpUI">HP: 100 / 100</div>
        <div class="hud top-4 right-4 text-yellow-400 font-bold" id="scoreUI">SCORE: 0</div>
        <div class="hud top-12 left-1/2 -translate-x-1/2 text-slate-500 text-xs" id="levelUI">LEVEL 1</div>
        <div class="hud bottom-4 left-1/2 -translate-x-1/2 text-red-500 font-bold animate-pulse">BOSS å¨è„…å·²åŠ å…¥æˆ°å ´</div>
    </div>

    <!-- åˆå§‹ä»‹é¢ -->
    <div id="startMenu" class="absolute inset-0 bg-slate-900/95 flex flex-col items-center justify-center z-50">
        <h1 class="text-6xl font-black mb-2 text-blue-500 text-center">æ¥µé™ç”Ÿå­˜<br><span class="text-3xl text-red-500">BOSS é™è‡¨</span></h1>
        <div id="userStats" class="mb-8 text-center bg-slate-800 p-4 rounded-xl border border-slate-700">
            <p class="text-slate-400">æœ€é«˜å¾—åˆ†: <span id="highScoreText" class="text-yellow-400 font-bold">è¼‰å…¥ä¸­...</span></p>
            <p class="text-slate-400">ç•¶å‰ UID: <span id="userIdDisplay" class="text-xs text-blue-300">å–å¾—ä¸­...</span></p>
        </div>
        <button id="btnStart" class="bg-blue-600 hover:bg-blue-500 px-12 py-4 rounded-full text-2xl font-bold transition-all transform hover:scale-110 shadow-lg shadow-blue-500/50">é€²å…¥æˆ°å ´</button>
    </div>

    <!-- å‡ç´šä»‹é¢ -->
    <div id="upgradeMenu" class="hidden absolute inset-0 bg-slate-950/90 flex flex-col items-center justify-center z-40">
        <h2 class="text-4xl font-black mb-8 text-blue-400">ç«åŠ›é€²éšï¼é¸æ“‡æ›´å¼·çš„å¼·åŒ–</h2>
        <div id="upgradeOptions" class="flex gap-6"></div>
    </div>

    <!-- çµæŸä»‹é¢ -->
    <div id="deathMenu" class="hidden absolute inset-0 bg-red-950/90 flex flex-col items-center justify-center z-50">
        <h1 class="text-6xl font-black mb-4 text-white">ä»»å‹™çµæŸ</h1>
        <p id="finalScore" class="text-2xl mb-2 text-red-200">å¾—åˆ†: 0</p>
        <p id="newRecordText" class="text-yellow-400 font-bold mb-8 opacity-0">æ–°ç´€éŒ„ï¼å·²å­˜æª”è‡³é›²ç«¯</p>
        <button onclick="location.reload()" class="bg-white text-red-900 px-10 py-3 rounded-full font-bold shadow-xl">å†æ¬¡æŒ‘æˆ°</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'survivor-game-default';

        let currentUser = null;
        let userSaveData = { highScore: 0 };

        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) { console.error("èªè­‰å¤±æ•—:", error); }
        };

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                document.getElementById('userIdDisplay').textContent = user.uid;
                await loadGameProgress();
            }
        });

        initAuth();

        async function loadGameProgress() {
            if (!currentUser) return;
            const docRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saveData', 'progress');
            try {
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) { userSaveData = docSnap.data(); }
                else { await setDoc(docRef, userSaveData); }
                document.getElementById('highScoreText').textContent = userSaveData.highScore;
            } catch (e) { document.getElementById('highScoreText').textContent = "0"; }
        }

        async function saveGameProgress(newScore) {
            if (!currentUser) return;
            const docRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saveData', 'progress');
            if (newScore > (userSaveData.highScore || 0)) {
                userSaveData.highScore = newScore;
                document.getElementById('newRecordText').style.opacity = 1;
            }
            try { await setDoc(docRef, userSaveData, { merge: true }); showSaveIndicator(); } catch (e) {}
        }

        function showSaveIndicator() {
            const el = document.getElementById('saveIndicator');
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 2000);
        }

        // --- éŠæˆ²é‚è¼¯ ---
        const audio = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(f, t, d, v=0.03) {
            try {
                if (audio.state === 'suspended') audio.resume();
                const o = audio.createOscillator();
                const g = audio.createGain();
                o.type = t; o.frequency.setValueAtTime(f, audio.currentTime);
                g.gain.setValueAtTime(v, audio.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, audio.currentTime + d);
                o.connect(g); g.connect(audio.destination);
                o.start(); o.stop(audio.currentTime + d);
            } catch(e) {}
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let w, h, player;
        let gameActive = false;
        let enemies = [], bullets = [], orbs = [], items = [], bossBullets = [];
        let frame = 0, score = 0, shootTimer = 0;
        let activeBoss = null;

        const camera = {
            x: 0, y: 0, zoom: 1, targetZoom: 1,
            update: function(targetX, targetY) {
                this.targetZoom = Math.max(0.4, 1 - (player.lv - 1) * 0.04);
                this.zoom += (this.targetZoom - this.zoom) * 0.05;
                this.x = targetX - (w / 2) / this.zoom;
                this.y = targetY - (h / 2) / this.zoom;
            },
            toScreen: function(worldX, worldY) {
                return { x: (worldX - this.x) * this.zoom, y: (worldY - this.y) * this.zoom };
            }
        };

        const UPGRADES = {
            bullets: { name: "æ¥µé™å½ˆé“", desc: "å†å¢åŠ  2 æ¢å°„æ“Šè·¯ç·š", icon: "ğŸš€", level: 5, max: 20 },
            fireRate: { name: "è¶…é »é€£ç™¼", desc: "æ”»é€Ÿçªç ´å¤©éš›", icon: "ğŸ”¥", level: 5, max: 20 },
            damage: { name: "æ¯€æ»…å½ˆé ­", desc: "å‚·å®³ç¿»å€", icon: "ğŸ’£", level: 5, max: 20 },
            speed: { name: "é–ƒé›»ç§»å‹•", desc: "ç§»å‹•é€Ÿåº¦åŠ å¼·", icon: "ğŸƒ", level: 0, max: 10 },
            magnet: { name: "å…¨åœ–æ‹¾å–", desc: "å¸å–ç¶“é©—ç¯„åœå¢åŠ ", icon: "ğŸª", level: 0, max: 10 }
        };

        function initCanvas() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; }
        window.addEventListener('resize', initCanvas);
        initCanvas();

        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        class Player {
            constructor() {
                this.x = 0; this.y = 0;
                this.r = 15; this.hp = 100; this.maxHp = 100;
                this.xp = 0; this.lv = 1; this.nextXp = 50;
                this.speed = 5; this.pickupR = 120;
                this.damage = 25; this.fireRate = 6; this.bulletCount = 3;
                this.damage += Math.floor((userSaveData.highScore || 0) * 0.01);
            }
            update() {
                if (keys['KeyW'] || keys['ArrowUp']) this.y -= this.speed;
                if (keys['KeyS'] || keys['ArrowDown']) this.y += this.speed;
                if (keys['KeyA'] || keys['ArrowLeft']) this.x -= this.speed;
                if (keys['KeyD'] || keys['ArrowRight']) this.x += this.speed;
                shootTimer++;
                if (shootTimer >= this.fireRate) { this.shoot(); shootTimer = 0; }
            }
            shoot() {
                let target = activeBoss || null;
                if (!target) {
                    let minDist = 1000;
                    enemies.forEach(e => {
                        const d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < minDist) { minDist = d; target = e; }
                    });
                }
                const angle = target ? Math.atan2(target.y - this.y, target.x - this.x) : -Math.PI/2;
                const spread = 0.35; 
                for (let i = 0; i < this.bulletCount; i++) {
                    const offset = (i - (this.bulletCount - 1) / 2) * spread;
                    bullets.push(new Bullet(this.x, this.y, angle + offset, this.damage));
                }
                playSfx(500, 'square', 0.05, 0.005);
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.shadowBlur = 15; ctx.shadowColor = '#3b82f6';
                ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI*2);
                ctx.fillStyle = '#3b82f6'; ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, angle, dmg) {
                this.x = x; this.y = y; this.dmg = dmg;
                this.vx = Math.cos(angle) * 15; this.vy = Math.sin(angle) * 15;
                this.r = 3; this.life = 120;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = '#60a5fa'; ctx.fill();
            }
        }

        class Enemy {
            constructor() {
                const spawnDist = (800 / camera.zoom);
                const angle = Math.random() * Math.PI * 2;
                this.x = player.x + Math.cos(angle) * spawnDist;
                this.y = player.y + Math.sin(angle) * spawnDist;
                this.r = 12 + Math.random() * 8;
                this.hp = 20 + player.lv * 10;
                this.speed = 1.0 + Math.random() * 1.5;
            }
            update() {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = '#ef4444'; ctx.fill();
            }
        }

        class Boss {
            constructor(lv) {
                const angle = Math.random() * Math.PI * 2;
                this.x = player.x + Math.cos(angle) * 600;
                this.y = player.y + Math.sin(angle) * 600;
                this.r = 60;
                this.maxHp = 2000 + lv * 1000;
                this.hp = this.maxHp;
                this.speed = 0.8;
                this.attackTimer = 0;
            }
            update() {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
                
                this.attackTimer++;
                if (this.attackTimer > 120) {
                    this.novaAttack();
                    this.attackTimer = 0;
                }
            }
            novaAttack() {
                playSfx(100, 'sawtooth', 0.5, 0.05);
                for (let i = 0; i < 24; i++) {
                    const angle = (Math.PI * 2 / 24) * i;
                    bossBullets.push(new BossBullet(this.x, this.y, angle));
                }
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.scale(camera.zoom, camera.zoom);
                
                // BOSS å¤–è§€
                ctx.beginPath();
                ctx.arc(0, 0, this.r, 0, Math.PI*2);
                const grad = ctx.createRadialGradient(0,0,0,0,0,this.r);
                grad.addColorStop(0, '#ef4444');
                grad.addColorStop(1, '#7f1d1d');
                ctx.fillStyle = grad;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // æ ¸å¿ƒ
                ctx.beginPath();
                ctx.arc(0, 0, this.r/2, 0, Math.PI*2);
                ctx.fillStyle = frame % 20 < 10 ? '#fff' : '#ef4444';
                ctx.fill();
                ctx.restore();
            }
        }

        class BossBullet {
            constructor(x, y, angle) {
                this.x = x; this.y = y;
                this.vx = Math.cos(angle) * 6;
                this.vy = Math.sin(angle) * 6;
                this.r = 8;
            }
            update() { this.x += this.vx; this.y += this.vy; }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = '#f87171';
                ctx.shadowBlur = 10; ctx.shadowColor = '#f87171';
                ctx.fill();
            }
        }

        class Orb {
            constructor(x, y, val=10) { this.x = x; this.y = y; this.r = 4; this.val = val; }
            update() {
                const d = Math.hypot(player.x - this.x, player.y - this.y);
                if (d < player.pickupR) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x += Math.cos(angle) * 12; this.y += Math.sin(angle) * 12;
                }
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = this.val > 50 ? '#8b5cf6' : '#fbbf24'; ctx.fill();
            }
        }

        function drawGrid() {
            ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1;
            const gridSize = 100 * camera.zoom;
            const offsetX = (-camera.x * camera.zoom) % gridSize;
            const offsetY = (-camera.y * camera.zoom) % gridSize;
            ctx.beginPath();
            for (let x = offsetX; x < w; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
            for (let y = offsetY; y < h; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
            ctx.stroke();
        }

        function spawnBoss() {
            document.getElementById('bossWarning').style.display = 'block';
            playSfx(50, 'sine', 2.0, 0.1);
            setTimeout(() => {
                document.getElementById('bossWarning').style.display = 'none';
                activeBoss = new Boss(player.lv);
                document.getElementById('bossHpContainer').style.display = 'block';
            }, 3000);
        }

        function showUpgrade() {
            gameActive = false;
            document.getElementById('upgradeMenu').classList.remove('hidden');
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';
            const pool = Object.keys(UPGRADES).filter(k => UPGRADES[k].level < UPGRADES[k].max);
            const picks = pool.sort(() => 0.5 - Math.random()).slice(0, 3);
            picks.forEach(key => {
                const up = UPGRADES[key];
                const card = document.createElement('div');
                card.className = "bg-slate-800 p-6 rounded-xl border-2 border-slate-700 hover:border-blue-500 cursor-pointer w-48 text-center transition-all hover:scale-105 shadow-lg";
                card.innerHTML = `<div class="text-4xl mb-4">${up.icon}</div><div class="font-bold text-xl mb-2">${up.name}</div><div class="text-xs text-slate-400 leading-tight">${up.desc}</div><div class="mt-4 text-blue-400 font-mono">LV ${up.level}</div>`;
                card.onclick = () => { 
                    applyUpgrade(key); 
                    document.getElementById('upgradeMenu').classList.add('hidden'); 
                    gameActive = true; 
                    if (player.lv % 5 === 0 && !activeBoss) spawnBoss(); // æ¯ 5 ç´šç”Ÿæˆ BOSS
                    loop(); 
                };
                options.appendChild(card);
            });
        }

        function applyUpgrade(key) {
            UPGRADES[key].level++;
            playSfx(600, 'triangle', 0.2, 0.1);
            if (key === 'bullets') player.bulletCount += 1;
            if (key === 'fireRate') player.fireRate = Math.max(1, player.fireRate - 1);
            if (key === 'damage') player.damage += 15;
            if (key === 'speed') player.speed += 0.8;
            if (key === 'magnet') player.pickupR += 80;
        }

        function loop() {
            if (!gameActive) return;
            ctx.clearRect(0, 0, w, h);
            frame++;
            camera.update(player.x, player.y);
            drawGrid();
            player.update();
            player.draw();

            if (!activeBoss && frame % Math.max(3, 20 - player.lv) === 0) enemies.push(new Enemy());

            // BOSS æ›´æ–°
            if (activeBoss) {
                activeBoss.update();
                activeBoss.draw();
                const hpPercent = (activeBoss.hp / activeBoss.maxHp) * 100;
                document.getElementById('bossHpBar').style.width = hpPercent + '%';
                
                // BOSS ç¢°æ’ç©å®¶
                if (Math.hypot(player.x - activeBoss.x, player.y - activeBoss.y) < player.r + activeBoss.r) {
                    player.hp -= 2;
                }
            }

            // BOSS å½ˆå¹•
            for (let i = bossBullets.length - 1; i >= 0; i--) {
                const b = bossBullets[i]; b.update(); b.draw();
                if (Math.hypot(player.x - b.x, player.y - b.y) < player.r + b.r) {
                    player.hp -= 10;
                    bossBullets.splice(i, 1);
                    continue;
                }
                if (Math.hypot(b.x - player.x, b.y - player.y) > 2000) bossBullets.splice(i, 1);
            }

            // ç©å®¶å­å½ˆ
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i]; b.update(); b.draw();
                
                if (activeBoss && Math.hypot(b.x - activeBoss.x, b.y - activeBoss.y) < activeBoss.r + b.r) {
                    activeBoss.hp -= b.dmg;
                    bullets.splice(i, 1);
                    if (activeBoss.hp <= 0) {
                        score += 500;
                        for(let k=0; k<20; k++) orbs.push(new Orb(activeBoss.x + Math.random()*40-20, activeBoss.y + Math.random()*40-20, 100));
                        activeBoss = null;
                        document.getElementById('bossHpContainer').style.display = 'none';
                        playSfx(200, 'sawtooth', 1.0, 0.1);
                    }
                    continue;
                }

                if (b.life <= 0) { bullets.splice(i, 1); continue; }
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (Math.hypot(e.x - b.x, e.y - b.y) < e.r + b.r) {
                        e.hp -= b.dmg; bullets.splice(i, 1);
                        if (e.hp <= 0) {
                            score += 10; orbs.push(new Orb(e.x, e.y));
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }

            // æ™®é€šæ•µäºº
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i]; e.update(); e.draw();
                if (Math.hypot(player.x - e.x, player.y - e.y) < player.r + e.r) {
                    player.hp -= 1.0;
                    document.body.classList.add('damage-flash');
                    setTimeout(() => document.body.classList.remove('damage-flash'), 50);
                }
            }

            if (player.hp <= 0) {
                gameActive = false;
                document.getElementById('deathMenu').classList.remove('hidden');
                document.getElementById('finalScore').textContent = `å¾—åˆ†: ${score}`;
                saveGameProgress(score);
                return;
            }

            // ç¶“é©—çƒ
            for (let i = orbs.length - 1; i >= 0; i--) {
                const o = orbs[i]; o.update(); o.draw();
                if (Math.hypot(player.x - o.x, player.y - o.y) < player.r + o.r) {
                    player.xp += o.val; orbs.splice(i, 1);
                    if (player.xp >= player.nextXp) {
                        player.lv++; player.xp = 0; player.nextXp = Math.floor(player.nextXp * 1.3);
                        showUpgrade(); return;
                    }
                }
            }

            document.getElementById('hpUI').textContent = `HP: ${Math.max(0, Math.ceil(player.hp))} / ${player.maxHp}`;
            document.getElementById('scoreUI').textContent = `SCORE: ${score}`;
            document.getElementById('levelUI').textContent = `LEVEL ${player.lv}`;
            document.getElementById('xpBar').style.width = (player.xp / player.nextXp * 100) + '%';
            requestAnimationFrame(loop);
        }

        document.getElementById('btnStart').onclick = () => {
            if (audio.state === 'suspended') audio.resume();
            document.getElementById('startMenu').classList.add('hidden');
            player = new Player();
            gameActive = true;
            loop();
        };
    </script>
</body>
</html>