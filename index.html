<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥µé™å€–å­˜è€…ï¼šç„¡é™ç«åŠ› - é€²éšæ­¦è£ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f172a; color: #f8fafc; font-family: 'Inter', sans-serif; overflow: hidden; }
        canvas { background-color: #111827; display: block; border-radius: 0.5rem; cursor: crosshair; }
        .hud { position: absolute; pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        #xpBarContainer {
            position: absolute; top: 0; left: 0; width: 100%; height: 8px;
            background: #1e293b; z-index: 10;
        }
        #xpBar { width: 0%; height: 100%; background: #3b82f6; transition: width 0.2s; }
        .damage-flash { animation: flash 0.15s; }
        @keyframes flash { 0% { background: rgba(220, 38, 38, 0.5); } 100% { background: transparent; } }
        
        .boss-warning { 
            position: absolute; top: 40%; left: 0; width: 100%; text-align: center;
            font-size: 5rem; font-weight: 900; color: #ef4444; z-index: 100;
            pointer-events: none; text-transform: uppercase; letter-spacing: 0.5rem;
            animation: boss-alert 1s infinite alternate;
            display: none;
        }
        @keyframes boss-alert { 0% { opacity: 0; transform: scale(0.9); } 100% { opacity: 1; transform: scale(1.1); } }
        
        .save-indicator { position: fixed; bottom: 1rem; right: 1rem; font-size: 0.75rem; color: #4ade80; opacity: 0; transition: opacity 0.5s; }
        #bossHpContainer { 
            position: absolute; top: 40px; left: 20%; width: 60%; height: 12px; 
            background: #450a0a; border: 2px solid #ef4444; border-radius: 6px; 
            display: none; z-index: 20;
        }
        #bossHpBar { width: 100%; height: 100%; background: #ef4444; transition: width 0.1s; }
        
        .custom-scroll::-webkit-scrollbar { width: 4px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #334155; border-radius: 10px; }
    </style>
</head>
<body class="flex items-center justify-center h-screen m-0">

    <div id="xpBarContainer"><div id="xpBar"></div></div>
    <div id="bossHpContainer"><div id="bossHpBar"></div></div>
    <div id="bossWarning" class="boss-warning">BOSS WARNING</div>
    <div id="saveIndicator" class="save-indicator">å·²åŒæ­¥é›²ç«¯é€²åº¦...</div>

    <div class="relative w-full h-full">
        <canvas id="gameCanvas"></canvas>
        <div class="hud top-4 left-4 text-green-400 font-bold" id="hpUI">HP: 100 / 100</div>
        <div class="hud top-4 right-4 text-yellow-400 font-bold" id="scoreUI">SCORE: 0</div>
        <div class="hud top-12 left-1/2 -translate-x-1/2 text-slate-500 text-xs" id="levelUI">LEVEL 1</div>
    </div>

    <!-- åˆå§‹ä»‹é¢ -->
    <div id="startMenu" class="absolute inset-0 bg-slate-900/95 flex flex-col md:flex-row items-center justify-center z-50 p-8 gap-8">
        <div class="flex flex-col items-center max-w-md">
            <h1 class="text-5xl font-black mb-2 text-blue-500 text-center uppercase tracking-tighter">Survivor<br><span class="text-2xl text-red-500">Elite Ops</span></h1>
            <div id="userStats" class="mb-6 w-full text-center bg-slate-800 p-4 rounded-xl border border-slate-700">
                <p class="text-slate-400">å€‹äººæœ€é«˜: <span id="highScoreText" class="text-yellow-400 font-bold">è¼‰å…¥ä¸­...</span></p>
                <p class="text-slate-500 text-[10px] mt-1 break-all">UID: <span id="userIdDisplay">å–å¾—ä¸­...</span></p>
            </div>
            <button id="btnStart" class="w-full bg-blue-600 hover:bg-blue-500 px-12 py-4 rounded-full text-2xl font-bold transition-all transform hover:scale-105 shadow-lg shadow-blue-500/50">é€²å…¥æˆ°å ´</button>
            <p class="text-slate-500 mt-4 text-sm">åˆå§‹è£å‚™ï¼šå–®ç™¼æ­¥æ§ã€‚å‡ç´šä»¥è§£é–å¤šé‡å½ˆé“ã€‚</p>
        </div>

        <!-- æ’è¡Œæ¦œé¢æ¿ -->
        <div class="bg-slate-800/50 border border-slate-700 rounded-2xl w-full max-w-xs h-[400px] flex flex-col overflow-hidden">
            <div class="bg-slate-700/50 p-3 text-center font-bold text-sm border-b border-slate-600">ä¸–ç•Œæ’è¡Œæ¦œ (TOP 20)</div>
            <div id="leaderboardList" class="flex-1 overflow-y-auto p-2 custom-scroll space-y-2">
                <div class="text-center text-slate-500 py-10 text-xs animate-pulse">æ­£åœ¨é€£æ¥æˆ°ç•¥ç¶²è·¯...</div>
            </div>
        </div>
    </div>

    <!-- å‡ç´šä»‹é¢ -->
    <div id="upgradeMenu" class="hidden absolute inset-0 bg-slate-950/90 flex flex-col items-center justify-center z-40">
        <h2 class="text-4xl font-black mb-8 text-blue-400">ç«åŠ›é€²éšï¼é¸æ“‡æ›´å¼·çš„å¼·åŒ–</h2>
        <div id="upgradeOptions" class="flex gap-6"></div>
    </div>

    <!-- çµæŸä»‹é¢ -->
    <div id="deathMenu" class="hidden absolute inset-0 bg-red-950/90 flex flex-col items-center justify-center z-50">
        <h1 class="text-6xl font-black mb-4 text-white">ä»»å‹™çµæŸ</h1>
        <p id="finalScore" class="text-2xl mb-2 text-red-200">å¾—åˆ†: 0</p>
        <p id="newRecordText" class="text-yellow-400 font-bold mb-8 opacity-0">æ–°ç´€éŒ„ï¼å·²å­˜æª”è‡³é›²ç«¯</p>
        <button onclick="location.reload()" class="bg-white text-red-900 px-10 py-3 rounded-full font-bold shadow-xl">å†æ¬¡æŒ‘æˆ°</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, onSnapshot, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'survivor-game-v2';

        let currentUser = null;
        let userSaveData = { highScore: 0 };

        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) { console.error("Auth Error:", error); }
        };

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                document.getElementById('userIdDisplay').textContent = user.uid;
                await loadGameProgress();
                setupLeaderboardListener();
            }
        });

        initAuth();

        async function loadGameProgress() {
            if (!currentUser) return;
            const docRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saveData', 'progress');
            try {
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) { 
                    userSaveData = docSnap.data(); 
                } else { 
                    await setDoc(docRef, userSaveData); 
                }
                document.getElementById('highScoreText').textContent = userSaveData.highScore || 0;
            } catch (e) { console.error("Load Progress Error:", e); }
        }

        function setupLeaderboardListener() {
            const leaderboardCol = collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
            onSnapshot(leaderboardCol, (snapshot) => {
                const listEl = document.getElementById('leaderboardList');
                let scores = [];
                snapshot.forEach(doc => scores.push(doc.data()));
                scores.sort((a, b) => b.score - a.score);
                scores = scores.slice(0, 20);
                listEl.innerHTML = '';
                if (scores.length === 0) {
                    listEl.innerHTML = '<div class="text-slate-600 text-center py-10 text-xs">å°šç„¡æˆ°é¬¥ç´€éŒ„</div>';
                    return;
                }
                scores.forEach((item, idx) => {
                    const isMe = currentUser && item.uid === currentUser.uid;
                    const row = document.createElement('div');
                    row.className = `flex items-center justify-between p-2 rounded-lg text-xs ${isMe ? 'bg-blue-900/40 border border-blue-500/50' : 'bg-slate-700/30'}`;
                    row.innerHTML = `
                        <div class="flex items-center gap-2 overflow-hidden">
                            <span class="font-bold w-4 ${idx < 3 ? 'text-yellow-400' : 'text-slate-500'}">${idx + 1}</span>
                            <span class="truncate text-slate-300 font-mono">${item.uid.substring(0, 8)}...</span>
                        </div>
                        <span class="font-bold text-blue-400">${item.score}</span>
                    `;
                    listEl.appendChild(row);
                });
            }, (error) => { console.error(error); });
        }

        async function saveGameProgress(newScore) {
            if (!currentUser) return;
            const docRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saveData', 'progress');
            if (newScore > (userSaveData.highScore || 0)) {
                userSaveData.highScore = newScore;
                document.getElementById('newRecordText').style.opacity = 1;
                try {
                    await setDoc(docRef, userSaveData, { merge: true });
                    const leaderboardDoc = doc(db, 'artifacts', appId, 'public', 'data', 'leaderboard', currentUser.uid);
                    await setDoc(leaderboardDoc, { uid: currentUser.uid, score: newScore, updatedAt: Date.now() });
                    showSaveIndicator();
                } catch (e) { console.error(e); }
            }
        }

        function showSaveIndicator() {
            const el = document.getElementById('saveIndicator');
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 2000);
        }

        const audio = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(f, t, d, v=0.03) {
            try {
                if (audio.state === 'suspended') audio.resume();
                const o = audio.createOscillator();
                const g = audio.createGain();
                o.type = t; o.frequency.setValueAtTime(f, audio.currentTime);
                g.gain.setValueAtTime(v, audio.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, audio.currentTime + d);
                o.connect(g); g.connect(audio.destination);
                o.start(); o.stop(audio.currentTime + d);
            } catch(e) {}
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let w, h, player;
        let gameActive = false;
        let enemies = [], bullets = [], orbs = [], bossBullets = [];
        let frame = 0, score = 0, shootTimer = 0;
        let activeBoss = null;

        const camera = {
            x: 0, y: 0, zoom: 1, targetZoom: 1,
            update: function(targetX, targetY) {
                this.targetZoom = Math.max(0.4, 1 - (player.lv - 1) * 0.04);
                this.zoom += (this.targetZoom - this.zoom) * 0.05;
                this.x = targetX - (w / 2) / this.zoom;
                this.y = targetY - (h / 2) / this.zoom;
            },
            toScreen: function(worldX, worldY) {
                return { x: (worldX - this.x) * this.zoom, y: (worldY - this.y) * this.zoom };
            }
        };

        // å‡ç´šè¨­å®šï¼šèª¿æ•´åˆå§‹ç­‰ç´šèˆ‡æè¿°
        const UPGRADES = {
            bullets: { name: "æ¥µé™å½ˆé“", desc: "å¢åŠ  1 æ¢é¡å¤–å°„æ“Šè·¯ç·š", icon: "ğŸš€", level: 0, max: 20 },
            fireRate: { name: "è¶…é »é€£ç™¼", desc: "æ”»é€Ÿæå‡", icon: "ğŸ”¥", level: 0, max: 20 },
            damage: { name: "æ¯€æ»…å½ˆé ­", desc: "åŸºç¤å‚·å®³åŠ æˆ", icon: "ğŸ’£", level: 0, max: 20 },
            speed: { name: "é–ƒé›»ç§»å‹•", desc: "è·‘ä½æ›´éˆæ´»", icon: "ğŸƒ", level: 0, max: 10 },
            magnet: { name: "å…¨åœ–æ‹¾å–", desc: "ç£åŠ›ç¯„åœæ“´å¼µ", icon: "ğŸª", level: 0, max: 10 }
        };

        function initCanvas() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; }
        window.addEventListener('resize', initCanvas);
        initCanvas();

        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        class Player {
            constructor() {
                this.x = 0; this.y = 0; this.r = 15; this.hp = 100; this.maxHp = 100;
                this.xp = 0; this.lv = 1; this.nextXp = 50;
                this.speed = 4.5; this.pickupR = 100;
                this.damage = 25;
                this.fireRate = 20; // åˆå§‹å°„é€Ÿè¼ƒæ…¢
                this.bulletCount = 1; // åˆå§‹åªæœ‰ä¸€ç™¼
            }
            update() {
                if (keys['KeyW'] || keys['ArrowUp']) this.y -= this.speed;
                if (keys['KeyS'] || keys['ArrowDown']) this.y += this.speed;
                if (keys['KeyA'] || keys['ArrowLeft']) this.x -= this.speed;
                if (keys['KeyD'] || keys['ArrowRight']) this.x += this.speed;
                shootTimer++;
                if (shootTimer >= this.fireRate) { this.shoot(); shootTimer = 0; }
            }
            shoot() {
                let target = activeBoss || null;
                if (!target) {
                    let minDist = 1000;
                    enemies.forEach(e => {
                        const d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < minDist) { minDist = d; target = e; }
                    });
                }
                const angle = target ? Math.atan2(target.y - this.y, target.x - this.x) : -Math.PI/2;
                const spread = 0.3; 
                for (let i = 0; i < this.bulletCount; i++) {
                    const offset = (i - (this.bulletCount - 1) / 2) * spread;
                    bullets.push(new Bullet(this.x, this.y, angle + offset, this.damage));
                }
                playSfx(400, 'square', 0.05, 0.02);
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI*2);
                ctx.fillStyle = '#3b82f6'; ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, angle, dmg) {
                this.x = x; this.y = y; this.dmg = dmg;
                this.vx = Math.cos(angle) * 12; this.vy = Math.sin(angle) * 12;
                this.r = 3.5; this.life = 100;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = '#60a5fa'; ctx.fill();
            }
        }

        class Enemy {
            constructor() {
                const spawnDist = (850 / camera.zoom);
                const angle = Math.random() * Math.PI * 2;
                this.x = player.x + Math.cos(angle) * spawnDist;
                this.y = player.y + Math.sin(angle) * spawnDist;
                this.r = 12 + Math.random() * 8;
                this.hp = 20 + player.lv * 12;
                this.speed = 1.2 + Math.random() * 1.2;
            }
            update() {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = '#ef4444'; ctx.fill();
            }
        }

        class Boss {
            constructor(lv) {
                const angle = Math.random() * Math.PI * 2;
                this.x = player.x + Math.cos(angle) * 600;
                this.y = player.y + Math.sin(angle) * 600;
                this.r = 60;
                this.maxHp = 2500 + lv * 1200;
                this.hp = this.maxHp;
                this.speed = 0.9;
                this.attackTimer = 0;
            }
            update() {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
                this.attackTimer++;
                if (this.attackTimer > 100) { this.novaAttack(); this.attackTimer = 0; }
            }
            novaAttack() {
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 / 20) * i;
                    bossBullets.push(new BossBullet(this.x, this.y, angle));
                }
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI*2);
                ctx.fillStyle = '#7f1d1d'; ctx.fill();
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 4; ctx.stroke();
                ctx.restore();
            }
        }

        class BossBullet {
            constructor(x, y, angle) {
                this.x = x; this.y = y;
                this.vx = Math.cos(angle) * 5; this.vy = Math.sin(angle) * 5;
                this.r = 8;
            }
            update() { this.x += this.vx; this.y += this.vy; }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = '#f87171'; ctx.fill();
            }
        }

        class Orb {
            constructor(x, y, val=10) { this.x = x; this.y = y; this.r = 4; this.val = val; }
            update() {
                const d = Math.hypot(player.x - this.x, player.y - this.y);
                if (d < player.pickupR) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x += Math.cos(angle) * 10; this.y += Math.sin(angle) * 10;
                }
            }
            draw() {
                const pos = camera.toScreen(this.x, this.y);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, this.r * camera.zoom, 0, Math.PI*2);
                ctx.fillStyle = this.val > 50 ? '#8b5cf6' : '#fbbf24'; ctx.fill();
            }
        }

        function drawGrid() {
            ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1;
            const gridSize = 100 * camera.zoom;
            const offsetX = (-camera.x * camera.zoom) % gridSize;
            const offsetY = (-camera.y * camera.zoom) % gridSize;
            ctx.beginPath();
            for (let x = offsetX; x < w; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
            for (let y = offsetY; y < h; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
            ctx.stroke();
        }

        function loop() {
            if (!gameActive) return;
            ctx.clearRect(0, 0, w, h);
            frame++;
            camera.update(player.x, player.y);
            drawGrid();
            player.update();
            player.draw();

            if (!activeBoss && frame % Math.max(5, 30 - player.lv) === 0) enemies.push(new Enemy());
            if (activeBoss) {
                activeBoss.update(); activeBoss.draw();
                const hpPercent = (activeBoss.hp / activeBoss.maxHp) * 100;
                document.getElementById('bossHpBar').style.width = hpPercent + '%';
                if (Math.hypot(player.x - activeBoss.x, player.y - activeBoss.y) < player.r + activeBoss.r) player.hp -= 2;
            }

            for (let i = bossBullets.length - 1; i >= 0; i--) {
                const b = bossBullets[i]; b.update(); b.draw();
                if (Math.hypot(player.x - b.x, player.y - b.y) < player.r + b.r) { player.hp -= 12; bossBullets.splice(i, 1); playSfx(150, 'sawtooth', 0.1); }
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i]; b.update(); b.draw();
                if (activeBoss && Math.hypot(b.x - activeBoss.x, b.y - activeBoss.y) < activeBoss.r + b.r) {
                    activeBoss.hp -= b.dmg; bullets.splice(i, 1);
                    if (activeBoss.hp <= 0) {
                        score += 1000; for(let k=0; k<20; k++) orbs.push(new Orb(activeBoss.x + Math.random()*60-30, activeBoss.y + Math.random()*60-30, 100));
                        activeBoss = null; document.getElementById('bossHpContainer').style.display = 'none';
                    }
                    continue;
                }
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (Math.hypot(e.x - b.x, e.y - b.y) < e.r + b.r) {
                        e.hp -= b.dmg; bullets.splice(i, 1);
                        if (e.hp <= 0) { score += 15; orbs.push(new Orb(e.x, e.y)); enemies.splice(j, 1); }
                        break;
                    }
                }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i]; e.update(); e.draw();
                if (Math.hypot(player.x - e.x, player.y - e.y) < player.r + e.r) {
                    player.hp -= 0.6; document.body.classList.add('damage-flash');
                    setTimeout(() => document.body.classList.remove('damage-flash'), 50);
                }
            }

            if (player.hp <= 0) {
                gameActive = false;
                document.getElementById('deathMenu').classList.remove('hidden');
                document.getElementById('finalScore').textContent = `å¾—åˆ†: ${score}`;
                saveGameProgress(score); return;
            }

            for (let i = orbs.length - 1; i >= 0; i--) {
                const o = orbs[i]; o.update(); o.draw();
                if (Math.hypot(player.x - o.x, player.y - o.y) < player.r + o.r) {
                    player.xp += o.val; orbs.splice(i, 1);
                    if (player.xp >= player.nextXp) {
                        player.lv++; player.xp = 0; player.nextXp = Math.floor(player.nextXp * 1.35);
                        showUpgrade(); return;
                    }
                }
            }

            document.getElementById('hpUI').textContent = `HP: ${Math.max(0, Math.ceil(player.hp))} / ${player.maxHp}`;
            document.getElementById('scoreUI').textContent = `SCORE: ${score}`;
            document.getElementById('levelUI').textContent = `LEVEL ${player.lv}`;
            document.getElementById('xpBar').style.width = (player.xp / player.nextXp * 100) + '%';
            requestAnimationFrame(loop);
        }

        function showUpgrade() {
            gameActive = false;
            document.getElementById('upgradeMenu').classList.remove('hidden');
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';
            const pool = Object.keys(UPGRADES).filter(k => UPGRADES[k].level < UPGRADES[k].max);
            const picks = pool.sort(() => 0.5 - Math.random()).slice(0, 3);
            picks.forEach(key => {
                const up = UPGRADES[key];
                const card = document.createElement('div');
                card.className = "bg-slate-800 p-6 rounded-xl border-2 border-slate-700 hover:border-blue-500 cursor-pointer w-48 text-center transition-all hover:scale-105 shadow-lg";
                card.innerHTML = `<div class="text-4xl mb-4">${up.icon}</div><div class="font-bold text-xl mb-2">${up.name}</div><div class="text-xs text-slate-400 leading-tight">${up.desc}</div><div class="mt-4 text-blue-400 font-mono">LV ${up.level}</div>`;
                card.onclick = () => { applyUpgrade(key); document.getElementById('upgradeMenu').classList.add('hidden'); gameActive = true; if (player.lv % 5 === 0 && !activeBoss) spawnBoss(); loop(); };
                options.appendChild(card);
            });
        }

        function spawnBoss() {
            document.getElementById('bossWarning').style.display = 'block';
            setTimeout(() => {
                document.getElementById('bossWarning').style.display = 'none';
                activeBoss = new Boss(player.lv);
                document.getElementById('bossHpContainer').style.display = 'block';
            }, 3000);
        }

        function applyUpgrade(key) {
            UPGRADES[key].level++;
            if (key === 'bullets') player.bulletCount++;
            if (key === 'fireRate') player.fireRate = Math.max(5, player.fireRate - 3);
            if (key === 'damage') player.damage += 15;
            if (key === 'speed') player.speed += 0.5;
            if (key === 'magnet') player.pickupR += 60;
            playSfx(600, 'sine', 0.2);
        }

        document.getElementById('btnStart').onclick = () => {
            if (audio.state === 'suspended') audio.resume();
            document.getElementById('startMenu').classList.add('hidden');
            player = new Player(); gameActive = true; loop();
        };
    </script>
</body>
</html>